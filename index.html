<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Prism</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <style>
    :root {
      color-scheme: dark;
      font-family: 'Google Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --panel: #1a1a1a;
      --stroke: #2a2a2a;
      --primary: #E37434;
      --primary-hover: #f0854a;
      --bg: #0d0d0d;
      --text: #ffffff;
      --text-secondary: #b0b0b0;
      --input-bg: #222222;
      --input-border: #333333;
      --input-border-hover: #3d3d3d;
      --shadow-primary: rgba(0, 0, 0, 0.3);
    }

    * {
      box-sizing: border-box;
      user-select: none;
    }

    input,
    textarea {
      user-select: text;
    }

    body {
      margin: 0;
      background: #0d0d0d;
      height: 100vh;
      overflow: hidden;
      font-family: inherit;
      display: flex;
      color: var(--text);
    }

    .sidebar {
      width: 360px;
      min-width: 360px;
      background: var(--panel);
      border-right: 1px solid var(--stroke);
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      height: 100vh;
    }

    .sidebar::-webkit-scrollbar {
      width: 8px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: transparent;
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: var(--input-border);
      border-radius: 4px;
    }

    .sidebar::-webkit-scrollbar-thumb:hover {
      background: var(--input-border-hover);
    }

    .output-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #0d0d0d;
      position: relative;
      overflow: hidden;
      height: 100vh;
    }

    .canvas-root {
      position: relative;
      width: 100%;
      height: 100%;
      min-height: 600px;
    }

    .help-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background: rgba(26, 26, 26, 0.9);
      border: 1px solid var(--stroke);
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text);
      backdrop-filter: blur(8px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: all 0.15s ease, filter 0.1s ease;
    }

    .help-button:hover {
      background: rgba(40, 40, 40, 0.95);
      transform: scale(1.05);
    }

    .help-button .material-icons {
      filter: drop-shadow(0 0 0px rgba(255, 255, 255, 0));
      transition: filter 0.1s ease;
      font-size: 24px;
    }

    .help-button:hover .material-icons {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.48));
    }

    .help-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }

    .help-modal.visible {
      display: flex;
    }

    .help-modal-content {
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      position: relative;
      margin: 20px;
    }

    .help-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .help-modal-header h2 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      color: var(--text);
    }

    .help-modal-close {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.15s ease;
    }

    .help-modal-close:hover {
      background: var(--input-bg);
      color: var(--text);
    }

    .help-modal-close .material-icons {
      font-size: 20px;
    }

    .help-modal-content h3 {
      margin: 16px 0 8px 0;
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
    }

    .help-modal-content p {
      margin: 0 0 12px 0;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text-secondary);
    }

    .help-modal-content ul {
      margin: 0 0 12px 0;
      padding-left: 20px;
      font-size: 13px;
      line-height: 1.6;
      color: var(--text-secondary);
    }

    .help-modal-content li {
      margin-bottom: 6px;
    }

    .shell {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 500;
      letter-spacing: -0.01em;
      color: var(--text);
      transition: text-shadow 0.1s ease, filter 0.1s ease;
      cursor: default;
    }

    h1:hover {
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
    }

    h1 img {
      transition: filter 0.1s ease;
    }

    h1:hover img {
      filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.6));
    }

    .btn {
      background: var(--primary);
      color: white;
      border: none;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.15s ease;
      box-shadow: 0 4px 12px var(--shadow-primary);
    }

    .btn:hover {
      background: var(--primary-hover);
      box-shadow: 0 6px 16px var(--shadow-primary);
    }

    .btn:hover:not(#randomBtn):not(#exportBtn) .material-icons,
    .btn:hover:not(#randomBtn):not(#exportBtn) span:not(.material-icons) {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.48));
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.48);
      transition: filter 0.1s ease, text-shadow 0.1s ease;
    }

    .btn:not(#randomBtn):not(#exportBtn) .material-icons,
    .btn:not(#randomBtn):not(#exportBtn) span:not(.material-icons) {
      filter: drop-shadow(0 0 0px rgba(255, 255, 255, 0));
      text-shadow: 0 0 0px rgba(255, 255, 255, 0);
      transition: filter 0.1s ease, text-shadow 0.1s ease;
    }

    #randomBtn {
      background: #f5f5f5;
      color: #1a1a1a;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      font-weight: 700;
      position: relative;
      overflow: hidden;
      z-index: 0;
      transition: background 0.1s ease, box-shadow 0.1s ease;
    }

    #randomBtn > * {
      position: relative;
      z-index: 1;
    }

    #randomBtn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255, 89, 94, 0.8),
        rgba(255, 202, 58, 0.8),
        rgba(138, 201, 38, 0.8),
        rgba(25, 130, 196, 0.8),
        rgba(106, 76, 147, 0.8),
        transparent
      );
      transition: left 0s;
      pointer-events: none;
      z-index: 2;
      border-radius: 10px;
    }

    #randomBtn.animating::before {
      left: 100%;
      transition: left 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    #randomBtn:not(.animating)::before {
      left: -100%;
      transition: left 0s;
    }

    #randomBtn:hover {
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.48);
      transition: box-shadow 0.1s ease;
    }



    #randomBtn:active {
      transform: none;
    }

    #randomBtn .material-icons {
      color: #1a1a1a;
      position: relative;
      z-index: 1;
    }

    #randomBtn span:not(.material-icons) {
      position: relative;
      z-index: 1;
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn.loading {
      cursor: wait;
      opacity: 0.8;
      pointer-events: none;
    }

    .btn.loading .material-icons {
      animation: spin 1s linear infinite;
    }

    #exportBtn {
      min-width: 140px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 4px;
      transition: background 0.1s ease;
    }

    #exportBtn:hover {
      background: #FFEB3B !important;
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }

    .btn.secondary {
      background: var(--input-bg);
      color: var(--text);
      box-shadow: none;
      border: 1px solid var(--input-border);
    }

    .btn.secondary .material-icons,
    .btn.secondary span:not(.material-icons) {
      filter: drop-shadow(0 0 0px rgba(255, 255, 255, 0));
      text-shadow: 0 0 0px rgba(255, 255, 255, 0);
      transition: filter 0.1s ease, text-shadow 0.1s ease;
    }

    .btn.secondary:hover {
      background: #2a2a2a;
      border-color: var(--input-border-hover);
    }

    .btn.secondary:hover .material-icons,
    .btn.secondary:hover span:not(.material-icons) {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.48));
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.48);
    }

    .panel {
      background: var(--bg);
      border-radius: 14px;
      border: 1px solid var(--stroke);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .panel h3 {
      margin: 0 0 4px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    label {
      display: flex;
      flex-direction: column;
      font-size: 12px;
      color: var(--text-secondary);
      gap: 4px;
      font-weight: 500;
    }

    input,
    select {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--input-border);
      font-size: 14px;
      font-family: inherit;
      font-weight: 400;
      background: var(--input-bg);
      color: var(--text);
      transition: border-color 0.15s ease, background-color 0.15s ease;
    }

    input:hover,
    select:hover {
      border-color: var(--input-border-hover);
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: #f5f5f5;
      background: #2a2a2a;
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      background: var(--input-bg);
      border-radius: 4px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #f5f5f5;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid var(--bg);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #f5f5f5;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid var(--bg);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      appearance: none;
      margin: 0;
    }

    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    .slider-with-input {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .slider-with-input input[type="range"] {
      flex: 0.6;
    }

    .blend-mode-buttons {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      pointer-events: none;
    }

    .blend-mode-buttons > .blend-btn {
      pointer-events: auto;
    }

    #ditherAlgorithmButtons {
      grid-template-columns: repeat(5, 1fr);
      pointer-events: none;
    }

    #ditherAlgorithmButtons > .blend-btn {
      pointer-events: auto;
    }

    label > .blend-mode-buttons,
    label > #ditherAlgorithmButtons {
      pointer-events: none;
    }

    label > .blend-mode-buttons > .blend-btn,
    label > #ditherAlgorithmButtons > .blend-btn {
      pointer-events: auto;
    }

    .blend-btn {
      aspect-ratio: 1;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.15s ease;
      color: var(--text);
    }

    .blend-btn:hover {
      background: #2a2a2a;
      border-color: var(--input-border-hover);
      border-width: 1px;
    }

    #blendModeButtons > .blend-btn:hover .material-icons,
    #blendModeButtons > .blend-btn:hover .material-symbols-outlined {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.48)) !important;
    }

    #ditherAlgorithmButtons > .blend-btn:hover .material-icons,
    #ditherAlgorithmButtons > .blend-btn:hover .material-symbols-outlined {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.48)) !important;
    }

    .gradient-controls .blend-btn:hover .material-icons,
    .gradient-controls .blend-btn:hover .material-symbols-outlined {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.48));
    }

    .blend-btn.active {
      background: #f5f5f5;
      border-color: #f5f5f5;
      color: #1a1a1a;
    }

    .blend-btn.active .material-icons {
      color: #1a1a1a;
    }

    .blend-btn.disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }

    .blend-btn.disabled:hover {
      background: var(--input-bg);
      border-color: var(--input-border);
    }

    .blend-btn .material-icons,
    .blend-btn .material-symbols-outlined {
      font-size: 18px;
    }

    input:disabled,
    input[disabled] {
      opacity: 0.4;
      cursor: not-allowed;
    }

    input[type="range"]:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    input[type="range"]:disabled::-webkit-slider-thumb {
      cursor: not-allowed;
      opacity: 0.4;
    }

    input[type="range"]:disabled::-moz-range-thumb {
      cursor: not-allowed;
      opacity: 0.4;
    }

    label.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    label.disabled input,
    label.disabled input[type="range"] {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    #gradientCanvas,
    #xCurveCanvas,
    #yCurveCanvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    #gradientCanvas {
      pointer-events: none;
    }

    #xCurveCanvas,
    #yCurveCanvas {
      z-index: 1;
    }

    #xCurveCanvas,
    #yCurveCanvas {
      pointer-events: none;
      /* re-enabled for active curve */
    }

    #xCurveCanvas.curves-enabled,
    #yCurveCanvas.curves-enabled {
      pointer-events: all;
    }
    
    /* Ensure active curve is on top and receives events */
    #xCurveCanvas[style*="z-index: 10"],
    #yCurveCanvas[style*="z-index: 10"] {
      pointer-events: all !important;
    }

    #yCurveCanvas {
      mix-blend-mode: normal; /* Changed from multiply to normal for visibility */
      isolation: isolate;
    }

    #xCurveCanvas {
      mix-blend-mode: normal; /* Changed from screen to normal for visibility */
      isolation: isolate;
    }
    
    /* When curve is active, use normal blend mode */
    #yCurveCanvas.curves-enabled.active-curve {
      mix-blend-mode: normal;
    }

    #xCurveCanvas.curves-enabled.active-curve {
      mix-blend-mode: normal;
    }
    
    /* Inactive curves should also use normal blend mode for visibility */
    #yCurveCanvas.curves-enabled:not(.active-curve) {
      mix-blend-mode: normal;
    }

    #xCurveCanvas.curves-enabled:not(.active-curve) {
      mix-blend-mode: normal;
    }

    .legend {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-secondary);
      padding: 0 4px;
    }

    .palette-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 4px;
    }

    .swatch {
      width: 26px;
      height: 26px;
      border-radius: 6px;
      cursor: pointer;
      border: 1px solid rgba(0, 0, 0, 0.08);
      transition: transform 0.08s ease;
    }

    .swatch:hover {
      transform: scale(1.06);
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    /* iOS-style switch */
    .ios-switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 26px;
      flex-shrink: 0;
    }

    .ios-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .ios-switch-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255, 255, 255, 0.2);
      transition: 0.3s;
      border-radius: 26px;
    }

    .ios-switch-slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .ios-switch input:checked + .ios-switch-slider {
      background-color: #f5f5f5;
    }

    .ios-switch input:checked + .ios-switch-slider:before {
      transform: translateX(18px);
      background-color: #1a1a1a;
    }

    .ios-switch input:focus + .ios-switch-slider {
      box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.3);
    }

    .pill {
      padding: 6px 8px;
      border-radius: 10px;
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      font-size: 12px;
      font-family: inherit;
      font-weight: 400;
      color: var(--text);
    }

    .note {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .toggle-btn {
      border-radius: 999px;
      border: 1px solid var(--input-border);
      padding: 4px 10px;
      font-size: 11px;
      font-family: inherit;
      font-weight: 500;
      background: var(--input-bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .toggle-btn .material-icons,
    .toggle-btn span:not(.material-icons) {
      filter: drop-shadow(0 0 0px rgba(255, 255, 255, 0));
      text-shadow: 0 0 0px rgba(255, 255, 255, 0);
      transition: filter 0.1s ease, text-shadow 0.1s ease;
    }

    .toggle-btn:hover {
      background: #2a2a2a;
      border-color: var(--input-border-hover);
      border-width: 1px;
    }

    .toggle-btn:hover .material-icons,
    .toggle-btn:hover span:not(.material-icons) {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.48));
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.48);
    }

    .toggle-btn.on {
      background: #f5f5f5;
      color: #1a1a1a;
      border-color: transparent;
    }

    .toggle-btn.on:hover {
      background: #e8e8e8;
    }

    .toggle-btn.on:hover .material-icons,
    .toggle-btn.on:hover span:not(.material-icons) {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.48));
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.48);
    }

    .toggle-btn.on .material-icons {
      color: #1a1a1a;
    }

    .curve-toggle-group {
      display: inline-flex;
      border-radius: 999px;
      border: 1px solid var(--input-border);
      overflow: hidden;
      background: var(--input-bg);
    }

    .curve-toggle {
      border: none;
      padding: 8px 16px;
      font-size: 14px;
      font-family: inherit;
      font-weight: 500;
      background: transparent;
      cursor: pointer;
      color: var(--text);
      transition: all 0.15s ease;
    }

    .curve-toggle .material-icons,
    .curve-toggle span:not(.material-icons) {
      filter: drop-shadow(0 0 0px rgba(255, 255, 255, 0));
      text-shadow: 0 0 0px rgba(255, 255, 255, 0);
      transition: filter 0.1s ease, text-shadow 0.1s ease;
    }

    .curve-toggle:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .curve-toggle:hover .material-icons,
    .curve-toggle:hover span:not(.material-icons) {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.48));
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.48);
    }

    .curve-toggle.active {
      background: #f5f5f5;
      color: #1a1a1a;
    }

    .curve-toggle.active:hover {
      background: #e8e8e8;
    }

    .curve-toggle.active:hover .material-icons,
    .curve-toggle.active:hover span:not(.material-icons) {
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, 0.48));
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.48);
    }

    .gradient-picker-section {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .gradient-bar-container {
      position: relative;
      width: 100%;
      height: 40px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--input-border);
      cursor: pointer;
      background: linear-gradient(to right, #3b6bff, #8b5cf6);
    }

    .gradient-bar {
      width: 100%;
      height: 100%;
      position: relative;
    }

    .gradient-stops {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .gradient-stop {
      position: absolute;
      width: 24px;
      height: 32px;
      border: 2px solid rgba(255, 255, 255, 0.6);
      border-radius: 4px;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      pointer-events: all;
      transform: translate(-50%, -50%);
      top: 50%;
      transition: transform 0.1s ease, border-width 0.1s ease, border-color 0.1s ease;
    }

    .gradient-stop:hover {
      transform: translate(var(--stop-transform-x, -50%), -50%) scale(1.1);
    }

    .gradient-stop.selected {
      border: 4px solid white;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .gradient-controls {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      width: 100%;
      margin-top: 4px;
    }
    
    .gradient-controls-left {
      display: contents;
    }
    
    .gradient-controls-left .blend-btn:nth-child(1) {
      grid-column: 1 / 2;
    }
    
    .gradient-controls-left .blend-btn:nth-child(2) {
      grid-column: 2 / 3;
    }
    
    .gradient-controls-left .blend-btn:nth-child(3) {
      grid-column: 3 / 4;
    }
    
    .gradient-controls-right {
      display: contents;
    }
    
    .gradient-controls-right .blend-btn {
      grid-column: 6 / 7;
      justify-self: end;
    }

    .btn .material-icons,
    .toggle-btn .material-icons {
      font-size: 16px;
      vertical-align: middle;
      margin-right: 4px;
      line-height: 1;
    }

    .btn.secondary .material-icons {
      font-size: 14px;
    }

    .btn .material-icons:only-child,
    .toggle-btn .material-icons:only-child {
      margin-right: 0;
    }

    .stop-color-picker {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .color-picker-container {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .color-preview {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      border: 1px solid var(--input-border);
      cursor: pointer;
      flex-shrink: 0;
    }

    #colorHexInput {
      flex: 1;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--text);
      font-size: 13px;
      font-family: 'Monaco', 'Menlo', monospace;
    }

    .spectrum-container {
      position: relative;
      width: 100%;
      height: 200px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--input-border);
      cursor: crosshair;
    }

    #spectrumCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .spectrum-marker {
      position: absolute;
      width: 12px;
      height: 12px;
      border: 2px solid white;
      border-radius: 50%;
      pointer-events: none;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3);
      transform: translate(-50%, -50%);
    }

    .hue-slider-container {
      position: relative;
      width: 100%;
      height: 20px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--input-border);
      cursor: pointer;
    }

    #hueCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .hue-marker {
      position: absolute;
      top: 0;
      width: 4px;
      height: 100%;
      background: white;
      border: 1px solid rgba(0, 0, 0, 0.3);
      pointer-events: none;
      transform: translateX(-50%);
    }

    .floating-history {
      position: fixed;
      top: 20px;
      left: 380px;
      z-index: 1001;
      background: rgba(26, 26, 26, 0.9);
      padding: 8px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      border: 1px solid var(--stroke);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: flex;
      gap: 8px;
      align-items: center;
      box-sizing: border-box;
    }

    .floating-curves {
      position: fixed;
      top: 20px;
      left: calc(360px + (100vw - 360px) / 2);
      transform: translateX(-50%);
      z-index: 1000;
      background: rgba(26, 26, 26, 0.9);
      padding: 8px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      border: 1px solid var(--stroke);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: flex;
      gap: 8px;
      align-items: center;
      box-sizing: border-box;
    }
    
    .curve-separator {
      width: 1px;
      height: 24px;
      background: var(--stroke);
      margin: 0 4px;
      flex-shrink: 0;
    }

    .floating-export {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: rgba(26, 26, 26, 0.9);
      padding: 8px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      border: 1px solid var(--stroke);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      display: flex;
      gap: 8px;
      align-items: center;
      box-sizing: border-box;
    }
  </style>
</head>

<body>
  <div class="sidebar">
    <div class="shell">
      <header>
        <h1 style="display:flex; align-items:center; gap:12px;">
          <img src="logo.svg" alt="Prism" style="height:32px; width:auto;" />
          Prism
        </h1>
        <div class="row">
          <button class="btn" id="randomBtn"><span class="material-icons">auto_awesome</span> Randomize</button>
        </div>
      </header>

      <div class="panel">
        <h3>Canvas & Blending</h3>
        <div class="controls">
          <div style="display:flex; flex-direction:row; gap:12px; align-items:flex-start; width:100%;">
            <label style="margin:0; flex:1;">
              Width
              <input type="number" id="widthInput" value="900" min="200" max="2000" style="width:100%;" />
          </label>
            <label style="margin:0; flex:1;">
              Height
              <input type="number" id="heightInput" value="520" min="200" max="2000" style="width:100%;" />
          </label>
          </div>
          <label>Global blend
            <div class="blend-mode-buttons" id="blendModeButtons">
              <button class="blend-btn" data-mode="avg" title="Average"><span class="material-icons">blur_on</span></button>
              <button class="blend-btn" data-mode="mul" title="Multiply"><span class="material-icons">close</span></button>
              <button class="blend-btn" data-mode="screen" title="Screen"><span class="material-icons">add</span></button>
              <button class="blend-btn" data-mode="overlay" title="Overlay"><span class="material-icons">layers</span></button>
              <button class="blend-btn" data-mode="softlight" title="Soft Light"><span class="material-icons">wb_sunny</span></button>
              <button class="blend-btn" data-mode="hardlight" title="Hard Light"><span class="material-icons">brightness_high</span></button>
              <button class="blend-btn active" data-mode="difference" title="Difference"><span class="material-icons">compare</span></button>
              <button class="blend-btn" data-mode="exclusion" title="Exclusion"><span class="material-icons">remove_circle</span></button>
              <button class="blend-btn" data-mode="darken" title="Darken"><span class="material-icons">dark_mode</span></button>
              <button class="blend-btn" data-mode="lighten" title="Lighten"><span class="material-icons">light_mode</span></button>
              <button class="blend-btn" data-mode="colorburn" title="Color Burn"><span class="material-icons">whatshot</span></button>
              <button class="blend-btn" data-mode="colordodge" title="Color Dodge"><span class="material-icons">flare</span></button>
            </div>
            <select id="blendMode" style="display:none;">
              <option value="avg">Average</option>
              <option value="mul">Multiply</option>
              <option value="screen">Screen</option>
              <option value="overlay">Overlay</option>
              <option value="softlight">Soft Light</option>
              <option value="hardlight">Hard Light</option>
              <option value="difference" selected>Difference</option>
              <option value="exclusion">Exclusion</option>
              <option value="darken">Darken</option>
              <option value="lighten">Lighten</option>
              <option value="colorburn">Color Burn</option>
              <option value="colordodge">Color Dodge</option>
            </select>
          </label>
          <label>Feather
            <div class="slider-with-input">
            <input type="range" id="featherInput" value="18" min="0" max="40" />
              <input type="number" id="featherValue" value="18" min="0" max="40" style="width:60px; padding:4px 6px; font-size:12px;" />
            </div>
          </label>
          <label>Noise
            <div class="slider-with-input">
              <input type="range" id="noiseInput" value="6" min="0" max="30" />
              <input type="number" id="noiseValue" value="6" min="0" max="30" style="width:60px; padding:4px 6px; font-size:12px;" />
            </div>
          </label>
        </div>
        </div>

      <div class="panel">
        <h3>Colors</h3>
        <div class="gradient-picker-section">
          <label style="display:block; margin-bottom:0;">Gradient Colors</label>
          <div class="gradient-bar-container" style="margin-top:0;">
            <div class="gradient-bar" id="gradientBar"></div>
            <div class="gradient-stops" id="gradientStops"></div>
          </div>
          <div class="gradient-controls">
            <div class="gradient-controls-left">
              <button class="blend-btn" id="invertGradientBtn" title="Invert Gradient"><span class="material-icons">swap_horiz</span></button>
              <button class="blend-btn" id="redistributeStopsBtn" title="Redistribute Stops Evenly"><span class="material-symbols-outlined">align_justify_space_even</span></button>
              <button class="blend-btn" id="shuffleColorsBtn" title="Shuffle Colors"><span class="material-icons">shuffle</span></button>
            </div>
            <div class="gradient-controls-right">
              <button class="blend-btn" id="removeStopBtn" title="Remove Selected"><span class="material-icons">delete</span></button>
            </div>
          </div>
          <div class="color-picker-container" style="margin-top:12px;">
            <div class="color-preview" id="colorPreview" style="background:#ff595e;"></div>
            <input type="text" id="colorHexInput" value="#ff595e" placeholder="#ff595e" maxlength="7" />
          </div>
          <div class="stop-color-picker" id="stopColorPicker" style="display:none;">
          <div class="spectrum-container">
            <canvas id="spectrumCanvas" width="200" height="200"></canvas>
            <div class="spectrum-marker" id="spectrumMarker"></div>
          </div>
          <div class="hue-slider-container">
            <canvas id="hueCanvas" width="200" height="20"></canvas>
            <div class="hue-marker" id="hueMarker"></div>
          </div>
          </div>
          <div style="margin-top:12px; display:flex; flex-direction:column; gap:12px;">
            <button class="blend-btn" id="randomizeColorsBtn" title="Randomize Colors" style="width:100%; aspect-ratio: auto; height: auto; padding: 8px 12px; display: flex; align-items: center; justify-content: center; gap: 6px;">
              <span class="material-icons" style="font-size:18px;">palette</span>
              <span style="font-size:12px;">Randomize Colors</span>
            </button>
            <label style="font-size:11px; margin:0; width:100%;">
              Amount of colors
              <div class="slider-with-input" style="width:100%;">
                <input type="range" id="multiColorCountSlider" value="8" min="2" max="20" style="flex:1; min-width:0; max-width:calc(100% - 60px);" />
                <input type="number" id="multiColorCount" value="8" min="2" max="20" step="1" style="width:45px; padding:4px 6px; font-size:12px; flex-shrink:0;" />
              </div>
            </label>
          </div>
        </div>
      </div>


        <div class="panel">
        <h3>Dither</h3>
        <div class="controls">
          <div style="margin-bottom: 8px;">
            <label style="font-size:11px; display:block; margin-bottom:4px;">Enable dithering</label>
            <label class="ios-switch" style="display:block;">
              <input type="checkbox" id="ditherEnabled" />
              <span class="ios-switch-slider"></span>
            </label>
              </div>
          <label>
            Algorithm
            <div class="blend-mode-buttons" id="ditherAlgorithmButtons">
              <button class="blend-btn" data-algorithm="floyd-steinberg" title="Floyd-Steinberg"><span class="material-icons">grid_on</span></button>
              <button class="blend-btn" data-algorithm="ordered" title="Ordered (Bayer)"><span class="material-icons">view_module</span></button>
              <button class="blend-btn" data-algorithm="atkinson" title="Atkinson"><span class="material-icons">apps</span></button>
              <button class="blend-btn" data-algorithm="stucki" title="Stucki"><span class="material-icons">dashboard</span></button>
              <button class="blend-btn" data-algorithm="burkes" title="Burkes"><span class="material-icons">view_quilt</span></button>
            </div>
            <select id="ditherAlgorithm" style="display:none;">
              <option value="floyd-steinberg" selected>Floyd-Steinberg</option>
              <option value="ordered">Ordered (Bayer)</option>
              <option value="atkinson">Atkinson</option>
              <option value="stucki">Stucki</option>
              <option value="burkes">Burkes</option>
            </select>
            </label>
          <label>
            Levels
            <div class="slider-with-input">
              <input type="range" id="ditherLevelsSlider" value="2" min="2" max="8" />
              <input type="number" id="ditherLevels" value="2" min="2" max="256" step="1" style="width:60px; padding:4px 6px; font-size:12px;" />
          </div>
            <span class="note" style="font-size:11px; margin-top:4px;">Number of color levels (2-256)</span>
            </label>
          <div style="margin-top: 12px; padding: 10px; background: rgba(255, 255, 255, 0.03); border-radius: 6px; border: 1px solid var(--input-border);">
            <p style="margin: 0; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
              <strong style="color: var(--text);">Tip:</strong> When using dithering, for best results use canvas resolution under 1000px and export with 3â€“4x scale.
            </p>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div class="output-area">
    <div class="canvas-root">
      <canvas id="gradientCanvas" width="900" height="520"></canvas>
      <canvas id="xCurveCanvas" width="900" height="520"></canvas>
      <canvas id="yCurveCanvas" width="900" height="520"></canvas>
    </div>
  </div>

  <div class="floating-history">
    <button class="btn secondary" id="undoBtn" style="padding:8px 12px; font-size:13px;" title="Undo (Ctrl/Cmd+Z)"><span class="material-icons">undo</span> Undo</button>
    <button class="btn secondary" id="redoBtn" style="padding:8px 12px; font-size:13px;" title="Redo (Ctrl/Cmd+R)"><span class="material-icons">redo</span> Redo</button>
  </div>

  <div class="floating-curves">
    <div class="curve-toggle-group">
      <button class="curve-toggle active" id="editXBtn"><span class="material-icons" style="font-size:18px; vertical-align:middle;">show_chart</span> X</button>
      <button class="curve-toggle" id="editYBtn"><span class="material-icons" style="font-size:18px; vertical-align:middle; transform: rotate(90deg); display: inline-block;">show_chart</span> Y</button>
    </div>
    <button class="btn secondary" id="invertCurveBtn"
      style="padding:8px 12px; font-size:13px;"><span class="material-icons">swap_horiz</span> Invert</button>
    <button class="btn secondary" id="randomizeCurvesBtn" style="padding:8px 12px; font-size:13px;"><span class="material-icons">casino</span> Randomize Curves</button>
    <div class="curve-separator"></div>
    <button class="toggle-btn on" id="toggleCurvesBtn" style="padding:8px 12px; font-size:13px; width: 140px; flex-shrink:0; display: flex; align-items: center; justify-content: flex-start; gap: 4px;"><span class="material-icons toggle-curves-icon" style="width: 16px; flex-shrink: 0; display: inline-block; text-align: center;">visibility</span><span class="toggle-curves-text">Curves visible</span></button>
  </div>

  <div class="floating-export">
    <select id="exportScale"
      style="padding:10px 32px 10px 14px; border-radius:10px; border:1px solid var(--input-border); background:var(--input-bg); color:var(--text); font-size:14px; font-weight:600; cursor:pointer; appearance:none; -webkit-appearance:none; -moz-appearance:none; background-image:url('data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2212%22 height=%2212%22 viewBox=%220 0 12 12%22%3E%3Cpath fill=%22%23ffffff%22 d=%22M6 9L1 4h10z%22/%3E%3C/svg%3E'); background-repeat:no-repeat; background-position:right 12px center;">
      <option value="1">1x</option>
      <option value="2">2x</option>
      <option value="3">3x</option>
      <option value="4">4x</option>
    </select>
    <button class="btn" id="exportBtn"
      style="background:#A2D729; box-shadow:0 4px 12px rgba(162, 215, 41, 0.25); color:#1a1a1a; min-width: 140px; flex-shrink: 0; display: flex; align-items: center; justify-content: flex-start; gap: 4px;"><span class="material-icons export-icon" style="color:#1a1a1a; width: 16px; flex-shrink: 0; display: inline-block; text-align: center;">download</span><span class="export-text">Export PNG</span></button>
  </div>

  <button class="help-button" id="helpButton" title="Help">
    <span class="material-icons">help_outline</span>
  </button>

  <div class="help-modal" id="helpModal">
    <div class="help-modal-content">
      <div class="help-modal-header">
        <h2>How to Use Prism</h2>
        <button class="help-modal-close" id="closeHelpModal">
          <span class="material-icons">close</span>
        </button>
      </div>
      <div>
        <h3>Curves</h3>
        <p>Prism uses two curves (X and Y) to control the gradient. Switch between them using the X and Y tabs at the top.</p>
        
        <h3>Adding Points</h3>
        <p>Left click on a curve to add a new control point at that position.</p>
        
        <h3>Removing Points</h3>
        <p>Right click on a point to remove it from the curve.</p>
        
        <h3>Moving Points</h3>
        <p>Click and drag any point to adjust the curve shape. The active point will glow white and be slightly larger.</p>
        
        <h3>Gradient Stops</h3>
        <p>Click on the gradient bar to add color stops, or drag existing stops to reposition them. Click a stop to select it and change its color.</p>
        
        <h3>Randomize</h3>
        <p>Use the Randomize button to generate random curves, colors, and settings. Individual randomize buttons are available for colors and curves.</p>
      </div>
    </div>
  </div>

  <script>
    // Utility: Catmull-Rom spline for smooth curves through points.
    function catmullRom(p0, p1, p2, p3, t) {
      const v0 = (p2 - p0) * 0.5;
      const v1 = (p3 - p1) * 0.5;
      const t2 = t * t;
      const t3 = t2 * t;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 +
        (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 +
        v0 * t +
        p1;
    }

    // Seeded random number generator (Linear Congruential Generator)
    class SeededRNG {
      constructor(seed) {
        this.seed = seed || 0;
      }
      setSeed(seed) {
        this.seed = seed;
      }
      next() {
        // LCG parameters (used by many implementations)
        this.seed = (this.seed * 1664525 + 1013904223) % (2 ** 32);
        return (this.seed >>> 0) / (2 ** 32);
      }
      random() {
        return this.next();
      }
      randomInt(min, max) {
        return Math.floor(this.random() * (max - min + 1)) + min;
      }
    }

    class CurveEditor {
      constructor(canvas, orientation = 'horizontal', curveId = '') {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.orientation = orientation;
        this.curveId = curveId; // 'x' or 'y'
        this.points = [
          { t: 0.0, v: 0.0 },
          { t: 0.33, v: 0.7 },
          { t: 0.66, v: 0.3 },
          { t: 1.0, v: 1.0 },
        ];
        this.dragIndex = null;
        this.radius = 8;
        this.pointPadding = 2; // Padding to keep points from canvas edges
        this.maxPoints = 100; // Allow many points (effectively unlimited for manual addition)
        this.mousePos = null; // Track mouse position for preview line
        this.animationStartTime = null;
        this.previousDragIndex = null;
        this.animationDuration = 100; // 100ms
        this._bind();
        this.draw();
      }
      setMaxPoints(max) {
        this.maxPoints = Math.max(100, max); // Set high limit to allow many points
        this.enforceComplexity();
      }
      enforceComplexity() {
        // If we have more points than max, remove excess points (keep first and last)
        if (this.points.length > this.maxPoints) {
          const toRemove = this.points.length - this.maxPoints;
          // Remove points from the middle, keeping first and last
          const indicesToRemove = [];
          for (let i = 1; i < this.points.length - 1 && indicesToRemove.length < toRemove; i++) {
            indicesToRemove.push(i);
          }
          // Remove in reverse order to maintain indices
          indicesToRemove.reverse().forEach(idx => {
            this.points.splice(idx, 1);
          });
          this.draw();
        }
      }
      setPoints(pts) {
        this.points = pts.sort((a, b) => a.t - b.t);
        this.enforceComplexity();
        this.draw();
      }
      invert() {
        this.points.forEach(p => p.v = 1 - p.v);
        this.draw();
      }
      randomize(rng, complexity) {
        const r = rng || Math;
        const count = complexity || this.maxPoints;
        const pts = Array.from({ length: count }, (_, i) => ({
          t: i / (count - 1),
          v: r.random()
        }));
        this.setPoints(pts);
      }
      evaluateSamples(n) {
        const samples = [];
        for (let i = 0; i < n; i++) {
          samples.push(this.evaluate(i / (n - 1)));
        }
        return samples;
      }
      evaluate(t) {
        const pts = this.points;
        if (pts.length === 1) return pts[0].v;
        for (let i = 0; i < pts.length - 1; i++) {
          const p1 = pts[i];
          const p2 = pts[i + 1];
          if (t >= p1.t && t <= p2.t) {
            const p0 = pts[i - 1] || p1;
            const p3 = pts[i + 2] || p2;
            const localT = (t - p1.t) / (p2.t - p1.t || 1e-6);
            return catmullRom(p0.v, p1.v, p2.v, p3.v, localT);
          }
        }
        return t <= pts[0].t ? pts[0].v : pts[pts.length - 1].v;
      }
      _bind() {
        const pos = (e) => {
          const rect = this.canvas.getBoundingClientRect();
          // Convert display coordinates to normalized 0-1 coordinates
          // rect.width/height are CSS display size, canvas.width/height are internal buffer size
          return {
            x: (e.clientX - rect.left) / rect.width,
            y: (e.clientY - rect.top) / rect.height,
          };
        };
        this.canvas.addEventListener('pointerdown', (e) => {
          if (!this.canvas.classList.contains('curves-enabled')) return;
          const p = pos(e);
          const { hit, idx } = this._hitTest(p);
          if (hit) {
            this.previousDragIndex = this.dragIndex;
            this.dragIndex = idx;
            this.animationStartTime = performance.now();
            this.draw();
          } else {
            // add point (allow adding points by clicking on the curve)
              const t = this.orientation === 'horizontal' ? p.x : p.y;
              const v = this.orientation === 'horizontal' ? 1 - p.y : p.x;
              // Don't add if too close to endpoints (t=0 or t=1)
              if (t > 0.05 && t < 0.95) {
                // Calculate padding in normalized coordinates
                const paddingT = (this.radius + this.pointPadding) / (this.orientation === 'horizontal' ? this.canvas.width : this.canvas.height);
                const paddingV = (this.radius + this.pointPadding) / (this.orientation === 'horizontal' ? this.canvas.height : this.canvas.width);
                
                // Clamp the new point position
                const clampedT = Math.min(1 - paddingT, Math.max(paddingT, t));
                const clampedV = Math.min(1 - paddingV, Math.max(paddingV, v));
                
                // Save history when point is added
                if (typeof saveHistory === 'function') {
                  saveHistory();
                }
                this.points.push({ t: clampedT, v: clampedV });
                this.points.sort((a, b) => a.t - b.t);
                this.previousDragIndex = this.dragIndex;
                const newIndex = this.points.findIndex(pt => Math.abs(pt.t - clampedT) < 0.01 && Math.abs(pt.v - clampedV) < 0.01);
                this.dragIndex = newIndex;
                this.animationStartTime = performance.now();
                this.draw();
              // Trigger gradient update when point is added
              if (typeof renderGradient === 'function') {
                renderGradient();
              }
            }
          }
        });
        // Right-click to remove points
        this.canvas.addEventListener('contextmenu', (e) => {
          if (!this.canvas.classList.contains('curves-enabled')) return;
          e.preventDefault();
          const p = pos(e);
          const { hit, idx } = this._hitTest(p);
          // Ensure minimum of 2 points - can only remove if we have more than 2
          if (hit && this.points.length > 2) {
            // Don't remove if it's the first or last point (keep endpoints)
            if (idx > 0 && idx < this.points.length - 1) {
              this.points.splice(idx, 1);
              this.draw();
              // Trigger gradient update
              if (typeof renderGradient === 'function') {
                renderGradient();
              }
            }
          }
        });
        window.addEventListener('pointermove', (e) => {
          if (this.dragIndex === null) return;
          const p = pos(e);
          const t = this.orientation === 'horizontal' ? p.x : p.y;
          const v = this.orientation === 'horizontal' ? 1 - p.y : p.x;
          
          // Calculate padding in normalized coordinates (0-1)
          const paddingT = (this.radius + this.pointPadding) / (this.orientation === 'horizontal' ? this.canvas.width : this.canvas.height);
          const paddingV = (this.radius + this.pointPadding) / (this.orientation === 'horizontal' ? this.canvas.height : this.canvas.width);
          
          const clampedT = Math.min(1 - paddingT, Math.max(paddingT, t));
          const clampedV = Math.min(1 - paddingV, Math.max(paddingV, v));
          this.points[this.dragIndex] = { t: clampedT, v: clampedV };
          this.points.sort((a, b) => a.t - b.t);
          this.dragIndex = this.points.indexOf(this.points[this.dragIndex]);
          
          this.draw();
          // Update gradient when curve points are moved
          if (typeof renderGradient === 'function') {
            renderGradient();
          }
        });
        window.addEventListener('pointerup', () => { 
          if (this.dragIndex !== null) {
            // Save history when curve point drag ends
            if (typeof saveHistory === 'function') {
              saveHistory();
            }
            // Final update when dragging ends
            if (typeof renderGradient === 'function') {
              renderGradient();
            }
            // Start animation back to normal size
            const releasedIndex = this.dragIndex;
            this.previousDragIndex = releasedIndex;
            this.dragIndex = null;
            this.animationStartTime = performance.now();
            this.draw();
            // Clear previousDragIndex after animation completes
            setTimeout(() => {
              if (this.dragIndex === null && this.previousDragIndex === releasedIndex) {
                this.previousDragIndex = null;
              }
            }, this.animationDuration);
          }
        });
        
        // Helper to get active state
        const getActiveState = () => {
          try {
            if (typeof activeCurve !== 'undefined') {
              return this.curveId === activeCurve;
            }
          } catch (e) {
            // Fallback
          }
          return this.curveId === 'x'; // Default
        };
        
        // Track mouse position for preview line
        this.canvas.addEventListener('pointermove', (e) => {
          if (!this.canvas.classList.contains('curves-enabled')) {
            this.mousePos = null;
            this.draw(getActiveState());
            return;
          }
          const p = pos(e);
          this.mousePos = p;
          // Only redraw if not currently dragging a point
          if (this.dragIndex === null) {
            this.draw(getActiveState());
          }
        });
        
        this.canvas.addEventListener('pointerleave', () => {
          this.mousePos = null;
          this.draw(getActiveState());
        });
      }
      _hitTest(p) {
        const pts = this.points;
        for (let i = 0; i < pts.length; i++) {
          const pt = pts[i];
          const px = this.orientation === 'horizontal' ? pt.t : pt.v;
          const py = this.orientation === 'horizontal' ? 1 - pt.v : pt.t;
          const dx = (p.x - px);
          const dy = (p.y - py);
          if (Math.hypot(dx, dy) < 0.035) return { hit: true, idx: i };
        }
        return { hit: false, idx: -1 };
      }
      draw(isActiveOverride = null) {
        const { ctx, canvas } = this;
        const w = canvas.width;
        const h = canvas.height;
        ctx.clearRect(0, 0, w, h);
        
        // Handle size animation for active point
        const now = performance.now();
        
        // Calculate animation progress (0 to 1)
        let animationProgress = 1; // Default to fully animated
        if (this.animationStartTime !== null) {
          const elapsed = now - this.animationStartTime;
          animationProgress = Math.min(1, elapsed / this.animationDuration);
          // If animation is still in progress, request another frame
          if (animationProgress < 1) {
            requestAnimationFrame(() => this.draw(isActiveOverride));
          } else {
            // Animation complete, clear start time
            this.animationStartTime = null;
          }
        }
        // grid (50px squares)
        ctx.strokeStyle = 'rgba(75, 85, 99, 0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]);
        const gridSize = 50;
        // Draw vertical lines
        for (let x = gridSize; x < w; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.stroke();
        }
        // Draw horizontal lines
        for (let y = gridSize; y < h; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
          ctx.stroke();
        }
        ctx.setLineDash([]);
        // curve - check if this is the active curve
        // Use override if provided, otherwise try to access activeCurve
        let isActive = false;
        if (isActiveOverride !== null) {
          isActive = isActiveOverride;
        } else {
          try {
            if (typeof activeCurve !== 'undefined') {
              isActive = this.curveId === activeCurve;
            }
          } catch (e) {
            // If activeCurve not accessible, default to showing curve normally
            isActive = this.curveId === 'x'; // Default to x being active
          }
        }
        
        if (isActive) {
          // Active curve: white 4px stroke with 2px black outline
          // Use source-over to ensure strokes are drawn normally regardless of CSS blend mode
          ctx.save();
          ctx.globalCompositeOperation = 'source-over';
          ctx.globalAlpha = 1.0;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          // Build path once using Path2D so we can reuse it
          const path = new Path2D();
          const samples = 200;
          for (let i = 0; i <= samples; i++) {
            const t = i / samples;
            const v = this.evaluate(t);
            const px = this.orientation === 'horizontal' ? t * w : v * w;
            const py = this.orientation === 'horizontal' ? (1 - v) * h : t * h;
            if (i === 0) path.moveTo(px, py); else path.lineTo(px, py);
          }
          
          // Draw white stroke with glow effect
          ctx.shadowBlur = 12;
          ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 4;
          ctx.stroke(path);
          ctx.shadowBlur = 0;
          ctx.restore();
        } else {
          // Inactive curve: dashed, 50% transparent white
          ctx.save();
          ctx.globalCompositeOperation = 'source-over';
          ctx.setLineDash([4, 4]);
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        const samples = 200;
        for (let i = 0; i <= samples; i++) {
          const t = i / samples;
          const v = this.evaluate(t);
          const px = this.orientation === 'horizontal' ? t * w : v * w;
          const py = this.orientation === 'horizontal' ? (1 - v) * h : t * h;
          if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        }
        
        // Draw preview line if mouse is over canvas and this is the active curve
        if (isActive && this.mousePos !== null) {
          ctx.save();
          ctx.globalCompositeOperation = 'source-over';
          ctx.setLineDash([2, 2]);
          // Draw dark background line for better visibility
          ctx.beginPath();
          if (this.orientation === 'horizontal') {
            // For X axis (horizontal curve): draw vertical line at mouse X position
            const x = Math.max(0, Math.min(w, this.mousePos.x * w));
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
          } else {
            // For Y axis (vertical curve): draw horizontal line at mouse Y position
            const y = Math.max(0, Math.min(h, this.mousePos.y * h));
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
          }
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        }
        
        // points
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        this.points.forEach((pt, idx) => {
          // Calculate padding in pixels
          const paddingX = this.radius + this.pointPadding;
          const paddingY = this.radius + this.pointPadding;
          
          // Clamp point positions to stay within canvas bounds with padding
          const normalizedT = Math.min(1 - (paddingX / w), Math.max(paddingX / w, pt.t));
          const normalizedV = Math.min(1 - (paddingY / h), Math.max(paddingY / h, pt.v));
          
          const px = this.orientation === 'horizontal' ? normalizedT * w : normalizedV * w;
          const py = this.orientation === 'horizontal' ? (1 - normalizedV) * h : normalizedT * h;
          const isPointActive = this.dragIndex === idx;
          
          if (!isActive) {
            // Inactive curve: 50% transparent 3px white solid stroke (not dashed)
            ctx.globalAlpha = 0.5;
            ctx.setLineDash([]); // Ensure no dash
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(px, py, this.radius, 0, Math.PI * 2);
          ctx.stroke();
            ctx.globalAlpha = 1.0;
          } else {
            // Active curve: normal point styling
            // Calculate animated size
            let currentRadius = this.radius;
            let currentGlow = 0;
            const isAnimatingRelease = this.previousDragIndex === idx && this.dragIndex === null && this.animationStartTime !== null;
            
            if (isPointActive) {
              // Active point: animate size from normal to 20% larger
              const targetSize = this.radius * 1.2;
              currentRadius = this.radius + (targetSize - this.radius) * animationProgress;
              currentGlow = 12 * animationProgress; // Glow also animates
            } else if (isAnimatingRelease) {
              // Point was just released: animate back to normal size
              const targetSize = this.radius * 1.2;
              currentRadius = targetSize - (targetSize - this.radius) * animationProgress;
              currentGlow = 12 * (1 - animationProgress);
            }
            
            if (isPointActive || isAnimatingRelease) {
              // Active point or point being released: white glow effect
              ctx.shadowBlur = currentGlow;
              ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
              ctx.fillStyle = '#ffffff';
              ctx.beginPath();
              ctx.arc(px, py, currentRadius, 0, Math.PI * 2);
              ctx.fill();
              ctx.shadowBlur = 0;
            } else {
              // Non-active point: just white, no glow
              ctx.fillStyle = '#ffffff';
              ctx.beginPath();
              ctx.arc(px, py, currentRadius, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        });
        ctx.restore();
      }
    }

    // Main gradient logic
    const gradientCanvas = document.getElementById('gradientCanvas');
    const gctx = gradientCanvas.getContext('2d');
    const xEditor = new CurveEditor(document.getElementById('xCurveCanvas'), 'horizontal', 'x');
    const yEditor = new CurveEditor(document.getElementById('yCurveCanvas'), 'vertical', 'y');
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const blendMode = document.getElementById('blendMode');
    const blendModeButtons = document.getElementById('blendModeButtons');
    const noiseInput = document.getElementById('noiseInput');
    const noiseValue = document.getElementById('noiseValue');
    const featherInput = document.getElementById('featherInput');
    const featherValue = document.getElementById('featherValue');
    const ditherEnabled = document.getElementById('ditherEnabled');
    const ditherAlgorithm = document.getElementById('ditherAlgorithm');
    const ditherLevels = document.getElementById('ditherLevels');
    const ditherLevelsSlider = document.getElementById('ditherLevelsSlider');
    
    // Add event listeners for controls that affect the gradient
    blendMode.addEventListener('change', () => {
      renderGradient();
    });
    
    // Blend mode buttons
    blendModeButtons.querySelectorAll('.blend-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        saveHistory(); // Save state before changing blend mode
        const mode = btn.dataset.mode;
        blendMode.value = mode;
        blendModeButtons.querySelectorAll('.blend-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        renderGradient();
      });
    });
    
    // Sync blend mode select with buttons
    blendMode.addEventListener('change', () => {
      blendModeButtons.querySelectorAll('.blend-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.mode === blendMode.value);
      });
    });
    
    // Noise slider and input sync
    noiseInput.addEventListener('input', () => {
      noiseValue.value = noiseInput.value;
      renderGradient();
    });
    
    noiseValue.addEventListener('input', () => {
      const val = Math.min(30, Math.max(0, parseInt(noiseValue.value) || 0));
      noiseValue.value = val;
      noiseInput.value = val;
      renderGradient();
    });

    // Feather slider and input sync
    featherInput.addEventListener('input', () => {
      featherValue.value = featherInput.value;
      renderGradient();
    });
    
    featherValue.addEventListener('input', () => {
      const val = Math.min(40, Math.max(0, parseInt(featherValue.value) || 0));
      featherValue.value = val;
      featherInput.value = val;
      renderGradient();
    });
    
    // Dither controls
    const ditherAlgorithmButtons = document.getElementById('ditherAlgorithmButtons');
    
    function updateDitherAlgorithmButtons() {
      if (ditherAlgorithmButtons) {
        const buttons = ditherAlgorithmButtons.querySelectorAll('.blend-btn');
        if (ditherEnabled.checked) {
          // Show active state based on current algorithm
          buttons.forEach(b => {
            b.classList.remove('disabled');
            b.classList.toggle('active', b.dataset.algorithm === ditherAlgorithm.value);
          });
        } else {
          // Remove active state and add disabled state when dither is disabled
          buttons.forEach(b => {
            b.classList.remove('active');
            b.classList.add('disabled');
          });
        }
        
        // Grey out the Algorithm label container
        const algorithmContainer = ditherAlgorithmButtons.closest('label');
        if (algorithmContainer) {
          if (ditherEnabled.checked) {
            algorithmContainer.classList.remove('disabled');
          } else {
            algorithmContainer.classList.add('disabled');
          }
        }
      }
      
      // Update levels slider and input
      if (ditherLevelsSlider) {
        ditherLevelsSlider.disabled = !ditherEnabled.checked;
        // Grey out the label container
        const levelsContainer = ditherLevelsSlider.closest('label');
        if (levelsContainer) {
          if (ditherEnabled.checked) {
            levelsContainer.classList.remove('disabled');
          } else {
            levelsContainer.classList.add('disabled');
          }
        }
      }
      if (ditherLevels) {
        ditherLevels.disabled = !ditherEnabled.checked;
      }
    }

    function updateColorCountControls() {
      // Amount of colors slider is always active now
      if (multiColorCountSlider) {
        multiColorCountSlider.disabled = false;
        const colorCountContainer = multiColorCountSlider.closest('label');
        if (colorCountContainer) {
          colorCountContainer.classList.remove('disabled');
        }
      }
      if (multiColorCount) {
        multiColorCount.disabled = false;
      }
    }
    
    ditherEnabled.addEventListener('change', () => {
      saveHistory(); // Save state before changing dither
      updateDitherAlgorithmButtons();
      renderGradient();
    });
    
    // Dither algorithm buttons
    if (ditherAlgorithmButtons) {
      // Initialize button states
      updateDitherAlgorithmButtons();
      
      ditherAlgorithmButtons.querySelectorAll('.blend-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          if (!ditherEnabled.checked) return; // Don't allow selection when dither is off
          
          saveHistory(); // Save state before changing dither algorithm
          const algorithm = btn.dataset.algorithm;
          ditherAlgorithm.value = algorithm;
          updateDitherAlgorithmButtons();
          renderGradient();
        });
      });
    }
    
    // Sync dither algorithm select with buttons
    ditherAlgorithm.addEventListener('change', () => {
      saveHistory(); // Save state before changing dither algorithm
      updateDitherAlgorithmButtons();
      if (ditherEnabled.checked) {
        renderGradient();
      }
    });
    
    // Dither levels slider and input sync
    ditherLevelsSlider.addEventListener('input', () => {
      ditherLevels.value = ditherLevelsSlider.value;
      if (ditherEnabled.checked) {
        renderGradient();
      }
    });
    
    ditherLevels.addEventListener('change', () => {
      saveHistory(); // Save state before changing dither levels
      const val = Math.min(256, Math.max(2, parseInt(ditherLevels.value) || 2));
      ditherLevels.value = val;
      // Update slider only if value is within slider range (2-8)
      if (val >= 2 && val <= 8) {
        ditherLevelsSlider.value = val;
      }
      if (ditherEnabled.checked) {
        renderGradient();
      }
    });
    
    // Also save on slider change (when user releases)
    ditherLevelsSlider.addEventListener('change', () => {
      saveHistory(); // Save state when slider is released
      ditherLevels.value = ditherLevelsSlider.value;
      if (ditherEnabled.checked) {
        renderGradient();
      }
    });
    
    
    // Canvas size change handlers
    widthInput.addEventListener('change', () => {
      setCanvasSize();
    });
    
    heightInput.addEventListener('change', () => {
      setCanvasSize();
    });
    
    const exportScale = document.getElementById('exportScale');
    const gradientBar = document.getElementById('gradientBar');
    const gradientStops = document.getElementById('gradientStops');
    const removeStopBtn = document.getElementById('removeStopBtn');
    const stopColorPicker = document.getElementById('stopColorPicker');
    const colorHexInput = document.getElementById('colorHexInput');
    const colorPreview = document.getElementById('colorPreview');
    const spectrumCanvas = document.getElementById('spectrumCanvas');
    const spectrumCtx = spectrumCanvas.getContext('2d');
    const hueCanvas = document.getElementById('hueCanvas');
    const hueCtx = hueCanvas.getContext('2d');
    const spectrumMarker = document.getElementById('spectrumMarker');
    const hueMarker = document.getElementById('hueMarker');

    // Gradient stops state
    let stopIdCounter = 0;
    let gradientStopsArray = [
      { id: stopIdCounter++, position: 0, color: { r: 255, g: 89, b: 94 } },    // #ff595e
      { id: stopIdCounter++, position: 0.25, color: { r: 255, g: 202, b: 58 } }, // #ffca3a
      { id: stopIdCounter++, position: 0.5, color: { r: 138, g: 201, b: 38 } },   // #8ac926
      { id: stopIdCounter++, position: 0.75, color: { r: 25, g: 130, b: 196 } }, // #1982c4
      { id: stopIdCounter++, position: 1, color: { r: 106, g: 76, b: 147 } }      // #6a4c93
    ];
    let selectedStopIndex = 0;

    // Color picker state (for editing selected stop)
    let currentHue = 240; // Blue in HSL (0-360)
    let currentSaturation = 100; // 0-100
    let currentLightness = 50; // 0-100
    const toggleCurvesBtn = document.getElementById('toggleCurvesBtn');
    const toggleCurvesIcon = toggleCurvesBtn.querySelector('.toggle-curves-icon');
    const toggleCurvesText = toggleCurvesBtn.querySelector('.toggle-curves-text');
    const editXBtn = document.getElementById('editXBtn');
    const editYBtn = document.getElementById('editYBtn');
    const invertCurveBtn = document.getElementById('invertCurveBtn');
    const randomizeColorsBtn = document.getElementById('randomizeColorsBtn');
    const multiColorCount = document.getElementById('multiColorCount');
    const multiColorCountSlider = document.getElementById('multiColorCountSlider');
    const randomizeCurvesBtn = document.getElementById('randomizeCurvesBtn');
    // Seeded RNG for reproducible randomization
    const seededRNG = new SeededRNG(0);

    // Initialize complexity - fixed defaults: X = 4, Y = 3
    const initXComplexity = 4;
    const initYComplexity = 3;
    xEditor.setMaxPoints(initXComplexity);
    yEditor.setMaxPoints(initYComplexity);

    // When multi-color random is used, this holds an array of RGB colors.
    let activePalette = null;
    
    // Undo/Redo history (10 steps)
    const historyMaxSteps = 10;
    let history = [];
    let historyIndex = -1;
    let isRestoringHistory = false; // Flag to prevent saving history during restore
    
    // Save current state to history
    function saveHistory() {
      if (isRestoringHistory) return;
      
      // Remove any future history if we're not at the end
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      
      const state = {
        gradientStops: JSON.parse(JSON.stringify(gradientStopsArray)), // Deep copy
        xPoints: JSON.parse(JSON.stringify(xEditor.points)), // Deep copy
        yPoints: JSON.parse(JSON.stringify(yEditor.points)), // Deep copy
        canvasWidth: parseInt(widthInput.value) || 900,
        canvasHeight: parseInt(heightInput.value) || 520,
        blendMode: blendMode.value,
        noise: parseInt(noiseInput.value) || 0,
        feather: parseInt(featherInput.value) || 0,
        ditherEnabled: ditherEnabled.checked,
        ditherAlgorithm: ditherAlgorithm.value,
        ditherLevels: parseInt(ditherLevels.value) || 2
      };
      
      history.push(state);
      
      // Limit history to max steps
      if (history.length > historyMaxSteps) {
        history.shift(); // Remove oldest
      } else {
        historyIndex++;
      }
      
      // Update button states
      if (typeof updateHistoryButtons === 'function') {
        updateHistoryButtons();
      }
    }
    
    // Restore state from history
    function restoreHistory(direction) {
      if (direction === 'undo' && historyIndex > 0) {
        historyIndex--;
      } else if (direction === 'redo' && historyIndex < history.length - 1) {
        historyIndex++;
      } else {
        return; // Can't undo/redo further
      }
      
      const state = history[historyIndex];
      if (!state) return;
      
      isRestoringHistory = true;
      
      // Restore gradient stops
      gradientStopsArray = JSON.parse(JSON.stringify(state.gradientStops));
      renderGradientBar();
      
      // Restore curve points
      xEditor.setPoints(JSON.parse(JSON.stringify(state.xPoints)));
      yEditor.setPoints(JSON.parse(JSON.stringify(state.yPoints)));
      
      // Restore canvas size
      widthInput.value = state.canvasWidth;
      heightInput.value = state.canvasHeight;
      setCanvasSize();
      
      // Restore blend mode
      blendMode.value = state.blendMode;
      blendModeButtons.querySelectorAll('.blend-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.mode === state.blendMode);
      });
      
      // Restore noise and feather
      noiseInput.value = state.noise;
      noiseValue.value = state.noise;
      featherInput.value = state.feather;
      featherValue.value = state.feather;
      
      // Restore dither settings
      ditherEnabled.checked = state.ditherEnabled;
      ditherAlgorithm.value = state.ditherAlgorithm;
      ditherLevels.value = state.ditherLevels;
      ditherLevelsSlider.value = Math.min(8, Math.max(2, state.ditherLevels));
      
      // Update dither algorithm buttons
      ditherAlgorithmButtons.querySelectorAll('.blend-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.algorithm === state.ditherAlgorithm);
      });
      
      // Update UI states
      updateDitherAlgorithmButtons();
      
      // Redraw everything
      xEditor.draw(activeCurve === 'x');
      yEditor.draw(activeCurve === 'y');
      renderGradient();
      
      // Update button states
      if (typeof updateHistoryButtons === 'function') {
        updateHistoryButtons();
      }
      
      isRestoringHistory = false;
    }
    
    // Undo/Redo buttons
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    
    // Update button states based on history
    function updateHistoryButtons() {
      if (undoBtn) {
        // Can undo only if we have history and we're not at the first state
        const canUndo = history.length > 0 && historyIndex > 0;
        undoBtn.disabled = !canUndo;
        undoBtn.style.opacity = canUndo ? '1' : '0.5';
        undoBtn.style.cursor = canUndo ? 'pointer' : 'not-allowed';
        undoBtn.style.pointerEvents = canUndo ? 'auto' : 'none';
      }
      if (redoBtn) {
        // Can redo only if we have future history
        const canRedo = history.length > 0 && historyIndex < history.length - 1;
        redoBtn.disabled = !canRedo;
        redoBtn.style.opacity = canRedo ? '1' : '0.5';
        redoBtn.style.cursor = canRedo ? 'pointer' : 'not-allowed';
        redoBtn.style.pointerEvents = canRedo ? 'auto' : 'none';
      }
    }
    
    if (undoBtn) {
      undoBtn.addEventListener('click', (e) => {
        if (history.length === 0 || historyIndex <= 0) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        restoreHistory('undo');
        updateHistoryButtons();
      });
    }
    
    if (redoBtn) {
      redoBtn.addEventListener('click', (e) => {
        if (history.length === 0 || historyIndex >= history.length - 1) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        restoreHistory('redo');
        updateHistoryButtons();
      });
    }
    
    // Keyboard shortcuts for undo/redo
    document.addEventListener('keydown', (e) => {
      // Check for Ctrl/Cmd + Z (undo) or Ctrl/Cmd + Shift + Z / Ctrl/Cmd + R (redo)
      const isUndo = (e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey;
      const isRedo = ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) || 
                     ((e.ctrlKey || e.metaKey) && e.key === 'r');
      
      // Don't trigger if user is typing in an input field
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        // Allow undo/redo in text inputs, but check if it's a color/hex input
        if (e.target.id === 'colorHexInput' || e.target.type === 'text') {
          return; // Let browser handle text undo/redo
        }
      }
      
      if (isUndo) {
        if (history.length === 0 || historyIndex <= 0) {
          e.preventDefault();
          return;
        }
        e.preventDefault();
        restoreHistory('undo');
        updateHistoryButtons();
      } else if (isRedo) {
        if (history.length === 0 || historyIndex >= history.length - 1) {
          e.preventDefault();
          return;
        }
        e.preventDefault();
        restoreHistory('redo');
        updateHistoryButtons();
      }
    });
    
    // Set default color count to 8
    if (multiColorCountSlider) {
      multiColorCountSlider.value = 8;
    }
    if (multiColorCount) {
      multiColorCount.value = 8;
    }
    // Initialize color count controls (always enabled)
    updateColorCountControls();
    let curvesVisible = true;
    let activeCurve = 'x'; // 'x' or 'y'

    // Curves UI
    toggleCurvesBtn.addEventListener('click', () => {
      curvesVisible = !curvesVisible;
      toggleCurvesBtn.classList.toggle('on', curvesVisible);
      toggleCurvesIcon.textContent = curvesVisible ? 'visibility' : 'visibility_off';
      toggleCurvesText.textContent = curvesVisible ? 'Curves visible' : 'Curves hidden';
      document.getElementById('xCurveCanvas').style.display = curvesVisible ? '' : 'none';
      document.getElementById('yCurveCanvas').style.display = curvesVisible ? '' : 'none';
      // Also update class for hit testing
      if (curvesVisible) {
        document.getElementById('xCurveCanvas').classList.add('curves-enabled');
        document.getElementById('yCurveCanvas').classList.add('curves-enabled');
      } else {
        document.getElementById('xCurveCanvas').classList.remove('curves-enabled');
        document.getElementById('yCurveCanvas').classList.remove('curves-enabled');
      }
    });

    // Randomize curves button - randomize on click
    randomizeCurvesBtn.addEventListener('click', () => {
      saveHistory(); // Save state before randomizing curves
      const seed = Math.floor(Math.random() * 1000000);
      seededRNG.setSeed(seed);
      const xComplexity = Math.floor(Math.random() * 3) + 3; // 3, 4, or 5
      const yComplexity = Math.floor(Math.random() * 3) + 3; // 3, 4, or 5
      xEditor.randomize(seededRNG, xComplexity);
      yEditor.randomize(seededRNG, yComplexity);
      xEditor.setMaxPoints(xComplexity);
      yEditor.setMaxPoints(yComplexity);
      renderGradient();
    });

    // Determine which editor is active
    function updateActiveCurveUI() {
      editXBtn.classList.toggle('active', activeCurve === 'x');
      editYBtn.classList.toggle('active', activeCurve === 'y');
      // Bring canvas to front and manage pointer events
      const xCanvas = document.getElementById('xCurveCanvas');
      const yCanvas = document.getElementById('yCurveCanvas');
      
      if (activeCurve === 'x') {
        xCanvas.style.zIndex = 10;
        yCanvas.style.zIndex = 1;
        // Disable pointer events on inactive canvas to prevent blocking
        if (yCanvas.classList.contains('curves-enabled')) {
          yCanvas.style.pointerEvents = 'none';
        }
        xCanvas.style.pointerEvents = 'all';
        // Add active class for blend mode override
        xCanvas.classList.add('active-curve');
        yCanvas.classList.remove('active-curve');
      } else {
        xCanvas.style.zIndex = 1;
        yCanvas.style.zIndex = 10;
        // Disable pointer events on inactive canvas to prevent blocking
        if (xCanvas.classList.contains('curves-enabled')) {
          xCanvas.style.pointerEvents = 'none';
        }
        yCanvas.style.pointerEvents = 'all';
        // Add active class for blend mode override
        yCanvas.classList.add('active-curve');
        xCanvas.classList.remove('active-curve');
      }
      
      // Redraw curves to reflect active state
      xEditor.draw(activeCurve === 'x');
      yEditor.draw(activeCurve === 'y');
    }
    updateActiveCurveUI();

    editXBtn.addEventListener('click', () => {
      activeCurve = 'x';
      updateActiveCurveUI();
    });
    editYBtn.addEventListener('click', () => {
      activeCurve = 'y';
      updateActiveCurveUI();
    });

    invertCurveBtn.addEventListener('click', () => {
      if (activeCurve === 'x') xEditor.invert();
      else yEditor.invert();
      renderGradient();
    });

    function setCanvasSize() {
      saveHistory(); // Save state before changing canvas size
      // Get user-set dimensions
      const userW = parseInt(widthInput.value) || 900;
      const userH = parseInt(heightInput.value) || 520;

      // Set canvas to user dimensions directly
      gradientCanvas.width = userW;
      gradientCanvas.height = userH;
      document.getElementById('xCurveCanvas').width = userW;
      document.getElementById('xCurveCanvas').height = userH;
      document.getElementById('yCurveCanvas').width = userW;
      document.getElementById('yCurveCanvas').height = userH;

      // CSS will handle display sizing via max-width/max-height
      gradientCanvas.style.width = '';
      gradientCanvas.style.height = '';
      document.getElementById('xCurveCanvas').style.width = '';
      document.getElementById('xCurveCanvas').style.height = '';
      document.getElementById('yCurveCanvas').style.width = '';
      document.getElementById('yCurveCanvas').style.height = '';

      xEditor.draw(activeCurve === 'x');
      yEditor.draw(activeCurve === 'y');
      renderGradient();
    }

    function lerp(a, b, t) { return a + (b - a) * t; }

    // Get color from gradient stops at position t (0-1)
    function getColorFromGradient(t) {
      if (activePalette && activePalette.length > 0) {
        // Use random palette if enabled
        const seg = 1 / (activePalette.length - 1);
        const idxSeg = Math.min(activePalette.length - 2, Math.floor(t / seg));
        const localT = (t - idxSeg * seg) / seg;
        const c1 = activePalette[idxSeg];
        const c2 = activePalette[idxSeg + 1];
        return {
          r: lerp(c1.r, c2.r, localT),
          g: lerp(c1.g, c2.g, localT),
          b: lerp(c1.b, c2.b, localT),
        };
      }
      
      // Use gradient stops
      const stops = gradientStopsArray.sort((a, b) => a.position - b.position);
      if (t <= stops[0].position) return stops[0].color;
      if (t >= stops[stops.length - 1].position) return stops[stops.length - 1].color;
      
      for (let i = 0; i < stops.length - 1; i++) {
        const s1 = stops[i];
        const s2 = stops[i + 1];
        if (t >= s1.position && t <= s2.position) {
          const localT = (t - s1.position) / (s2.position - s1.position);
          return {
            r: lerp(s1.color.r, s2.color.r, localT),
            g: lerp(s1.color.g, s2.color.g, localT),
            b: lerp(s1.color.b, s2.color.b, localT),
          };
        }
      }
      return stops[0].color;
    }


    function renderGradient() {
      const w = gradientCanvas.width;
      const h = gradientCanvas.height;
      const xSamples = xEditor.evaluateSamples(w);
      const ySamples = yEditor.evaluateSamples(h);

      const img = gctx.createImageData(w, h);
      const noiseAmt = parseInt(noiseInput.value) / 100;
      const feather = parseInt(featherInput.value) / 100;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = (y * w + x) * 4;
          let vx = xSamples[x];
          let vy = ySamples[y];
          if (feather > 0) {
            const fx = Math.sin((x / w) * Math.PI) ** feather;
            const fy = Math.sin((y / h) * Math.PI) ** feather;
            vx = lerp(vx, fx, 0.2);
            vy = lerp(vy, fy, 0.2);
          }
          const mixVal = blend(vx, vy, blendMode.value);
          const n = (Math.random() - 0.5) * noiseAmt;
          const v = Math.min(1, Math.max(0, mixVal + n));

          const col = getColorFromGradient(v);

          img.data[idx + 0] = col.r;
          img.data[idx + 1] = col.g;
          img.data[idx + 2] = col.b;
          img.data[idx + 3] = 255;
        }
      }
      
      // Apply dithering if enabled
      if (ditherEnabled.checked) {
        applyDithering(img, ditherAlgorithm.value, parseInt(ditherLevels.value) || 256);
      }
      
      gctx.putImageData(img, 0, 0);
    }

    // Dithering algorithms
    function applyDithering(imgData, algorithm, levels) {
      const w = imgData.width;
      const h = imgData.height;
      const data = imgData.data;
      
      // Create a copy to work with
      const workingData = new Uint8ClampedArray(data);
      
      // Quantize function
      const quantize = (value) => {
        const step = 255 / (levels - 1);
        const quantized = Math.round(value / step) * step;
        return Math.max(0, Math.min(255, quantized));
      };
      
      // Get pixel value
      const getPixel = (x, y, channel) => {
        if (x < 0 || x >= w || y < 0 || y >= h) return 0;
        const idx = (y * w + x) * 4;
        return workingData[idx + channel];
      };
      
      // Set pixel value
      const setPixel = (x, y, channel, value) => {
        if (x < 0 || x >= w || y < 0 || y >= h) return;
        const idx = (y * w + x) * 4;
        workingData[idx + channel] = Math.max(0, Math.min(255, value));
      };
      
      // Add error to pixel
      const addError = (x, y, channel, error) => {
        if (x < 0 || x >= w || y < 0 || y >= h) return;
        const idx = (y * w + x) * 4;
        workingData[idx + channel] = Math.max(0, Math.min(255, workingData[idx + channel] + error));
      };
      
      switch (algorithm) {
        case 'floyd-steinberg': {
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              for (let c = 0; c < 3; c++) {
                const oldVal = getPixel(x, y, c);
                const newVal = quantize(oldVal);
                const error = oldVal - newVal;
                setPixel(x, y, c, newVal);
                
                addError(x + 1, y, c, error * 7 / 16);
                addError(x - 1, y + 1, c, error * 3 / 16);
                addError(x, y + 1, c, error * 5 / 16);
                addError(x + 1, y + 1, c, error * 1 / 16);
              }
            }
          }
          break;
        }
        
        case 'atkinson': {
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              for (let c = 0; c < 3; c++) {
                const oldVal = getPixel(x, y, c);
                const newVal = quantize(oldVal);
                const error = oldVal - newVal;
                setPixel(x, y, c, newVal);
                
                const fraction = error / 8;
                addError(x + 1, y, c, fraction);
                addError(x + 2, y, c, fraction);
                addError(x - 1, y + 1, c, fraction);
                addError(x, y + 1, c, fraction);
                addError(x + 1, y + 1, c, fraction);
                addError(x, y + 2, c, fraction);
              }
            }
          }
          break;
        }
        
        case 'stucki': {
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              for (let c = 0; c < 3; c++) {
                const oldVal = getPixel(x, y, c);
                const newVal = quantize(oldVal);
                const error = oldVal - newVal;
                setPixel(x, y, c, newVal);
                
                addError(x + 1, y, c, error * 8 / 42);
                addError(x + 2, y, c, error * 4 / 42);
                addError(x - 2, y + 1, c, error * 2 / 42);
                addError(x - 1, y + 1, c, error * 4 / 42);
                addError(x, y + 1, c, error * 8 / 42);
                addError(x + 1, y + 1, c, error * 4 / 42);
                addError(x + 2, y + 1, c, error * 2 / 42);
                addError(x - 2, y + 2, c, error * 1 / 42);
                addError(x - 1, y + 2, c, error * 2 / 42);
                addError(x, y + 2, c, error * 4 / 42);
                addError(x + 1, y + 2, c, error * 2 / 42);
                addError(x + 2, y + 2, c, error * 1 / 42);
              }
            }
          }
          break;
        }
        
        case 'burkes': {
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              for (let c = 0; c < 3; c++) {
                const oldVal = getPixel(x, y, c);
                const newVal = quantize(oldVal);
                const error = oldVal - newVal;
                setPixel(x, y, c, newVal);
                
                addError(x + 1, y, c, error * 8 / 32);
                addError(x + 2, y, c, error * 4 / 32);
                addError(x - 2, y + 1, c, error * 2 / 32);
                addError(x - 1, y + 1, c, error * 4 / 32);
                addError(x, y + 1, c, error * 8 / 32);
                addError(x + 1, y + 1, c, error * 4 / 32);
                addError(x + 2, y + 1, c, error * 2 / 32);
              }
            }
          }
          break;
        }
        
        case 'ordered': {
          // Bayer 8x8 matrix
          const bayerMatrix = [
            [0, 32, 8, 40, 2, 34, 10, 42],
            [48, 16, 56, 24, 50, 18, 58, 26],
            [12, 44, 4, 36, 14, 46, 6, 38],
            [60, 28, 52, 20, 62, 30, 54, 22],
            [3, 35, 11, 43, 1, 33, 9, 41],
            [51, 19, 59, 27, 49, 17, 57, 25],
            [15, 47, 7, 39, 13, 45, 5, 37],
            [63, 31, 55, 23, 61, 29, 53, 21]
          ];
          
          const step = 255 / (levels - 1);
          
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              for (let c = 0; c < 3; c++) {
                const idx = (y * w + x) * 4;
                const oldVal = workingData[idx + c];
                // Normalize bayer matrix value (0-63) to threshold (-0.5 to 0.5)
                const threshold = (bayerMatrix[y % 8][x % 8] / 64 - 0.5) * step;
                const newVal = oldVal + threshold;
                const quantized = quantize(newVal);
                workingData[idx + c] = quantized;
              }
            }
          }
          break;
        }
      }
      
      // Copy working data back to original
      for (let i = 0; i < data.length; i++) {
        data[i] = workingData[i];
      }
    }

    function blend(a, b, mode) {
      // Normalize inputs to 0-1 range
      const base = Math.min(1, Math.max(0, a));
      const blend = Math.min(1, Math.max(0, b));

      switch (mode) {
        case 'mul':
          return base * blend;
        case 'screen':
          return 1 - (1 - base) * (1 - blend);
        case 'overlay':
          return base < 0.5
            ? 2 * base * blend
            : 1 - 2 * (1 - base) * (1 - blend);
        case 'softlight':
          return blend < 0.5
            ? 2 * base * blend + base * base * (1 - 2 * blend)
            : Math.sqrt(base) * (2 * blend - 1) + 2 * base * (1 - blend);
        case 'hardlight':
          return blend < 0.5
            ? 2 * base * blend
            : 1 - 2 * (1 - base) * (1 - blend);
        case 'difference':
          return Math.abs(base - blend);
        case 'exclusion':
          return base + blend - 2 * base * blend;
        case 'darken':
          return Math.min(base, blend);
        case 'lighten':
          return Math.max(base, blend);
        case 'colorburn':
          return blend === 0 ? 0 : Math.max(0, 1 - (1 - base) / blend);
        case 'colordodge':
          return blend === 1 ? 1 : Math.min(1, base / (1 - blend));
        case 'avg':
        default:
          return (base + blend) / 2;
      }
    }


    // Export
    // Export
    const exportBtn = document.getElementById('exportBtn');
    const exportBtnIcon = exportBtn.querySelector('.export-icon');
    const exportBtnText = exportBtn.querySelector('.export-text');
    
    exportBtn.addEventListener('click', () => {
      // Show loading state
      exportBtn.classList.add('loading');
      exportBtn.disabled = true;
      const originalIcon = exportBtnIcon.textContent;
      const originalText = exportBtnText.textContent;
      exportBtnIcon.textContent = 'hourglass_empty';
      exportBtnText.textContent = 'Exporting...';
      
      // Use requestAnimationFrame to allow UI to update before heavy processing
      requestAnimationFrame(() => {
        setTimeout(() => {
          try {
      const scale = parseInt(exportScale.value) || 1;
      const originalWidth = gradientCanvas.width;
      const originalHeight = gradientCanvas.height;

      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = originalWidth * scale;
      exportCanvas.height = originalHeight * scale;
      const exportCtx = exportCanvas.getContext('2d');

            // If scale is 1x and no dithering, copy directly from preview
            // If dithering is enabled, re-render with 256 levels to preserve full color depth
            if (scale === 1 && !ditherEnabled.checked) {
              exportCtx.drawImage(gradientCanvas, 0, 0);
            } else {
              // Re-render the gradient (for both 1x with dithering and scaled exports)
              // This ensures we apply dithering with full color depth (256 levels) for export
              // For scaled exports, we need to render at the new size
              // Use seeded RNG to match preview if possible, or render fresh
      const xSamples = xEditor.evaluateSamples(exportCanvas.width);
      const ySamples = yEditor.evaluateSamples(exportCanvas.height);
      const img = exportCtx.createImageData(exportCanvas.width, exportCanvas.height);
              
              // Validate ImageData was created correctly
              if (!img || !img.data || !img.width || !img.height) {
                throw new Error('Failed to create ImageData for export');
              }
              
      const noiseAmt = parseInt(noiseInput.value) / 100;
      const feather = parseInt(featherInput.value) / 100;

      for (let y = 0; y < exportCanvas.height; y++) {
        for (let x = 0; x < exportCanvas.width; x++) {
          const idx = (y * exportCanvas.width + x) * 4;
          let vx = xSamples[x];
          let vy = ySamples[y];
          if (feather > 0) {
            const fx = Math.sin((x / exportCanvas.width) * Math.PI) ** feather;
            const fy = Math.sin((y / exportCanvas.height) * Math.PI) ** feather;
            vx = lerp(vx, fx, 0.2);
            vy = lerp(vy, fy, 0.2);
          }
          const mixVal = blend(vx, vy, blendMode.value);
          const n = (Math.random() - 0.5) * noiseAmt;
          const v = Math.min(1, Math.max(0, mixVal + n));

                  const col = getColorFromGradient(v);

          img.data[idx + 0] = col.r;
          img.data[idx + 1] = col.g;
          img.data[idx + 2] = col.b;
          img.data[idx + 3] = 255;
        }
      }
                  
              // Apply dithering if enabled
              // Use the UI's level setting to create the visible dithering pattern
              if (ditherEnabled.checked) {
                try {
                  // Validate ImageData before dithering
                  if (!img.width || !img.height || !img.data) {
                    throw new Error('Invalid ImageData before dithering');
                  }
                  // Apply dithering with the UI's level setting to create the visual pattern
                  const ditherLevelsValue = parseInt(ditherLevels.value) || 256;
                  applyDithering(img, ditherAlgorithm.value, ditherLevelsValue);
                  // Validate ImageData after dithering
                  if (!img.width || !img.height || !img.data) {
                    throw new Error('ImageData corrupted after dithering');
                  }
                } catch (ditherError) {
                  console.error('Dithering error details:', ditherError);
                  console.error('ImageData state:', { width: img.width, height: img.height, dataLength: img.data ? img.data.length : 'no data' });
                  throw new Error('Dithering failed: ' + ditherError.message);
                }
              }
              
              // Put the image data to canvas
              // PNG export from canvas is always RGB mode (not indexed/palette)
              // even if the ImageData has quantized colors
      exportCtx.putImageData(img, 0, 0);
            }

            // Build comprehensive filename
            const width = exportCanvas.width;
            const height = exportCanvas.height;
            const noiseVal = parseInt(noiseInput.value);
            const featherVal = parseInt(featherInput.value);
            
            // Get colors from gradient stops (sorted by position)
            const sortedStops = [...gradientStopsArray].sort((a, b) => a.position - b.position);
            const colors = sortedStops.map(stop => {
              const hex = rgbToHex(stop.color.r, stop.color.g, stop.color.b);
              return hex.substring(1); // Remove # prefix
            }).join('-');
            
            // Get dither info if enabled
            let ditherInfo = '';
            if (ditherEnabled.checked) {
              const ditherAlgo = ditherAlgorithm.value.replace('-', '_');
              const ditherLevelsValue = parseInt(ditherLevels.value) || 256;
              ditherInfo = `_dither-${ditherAlgo}-${ditherLevelsValue}`;
            }
            
            // Get X curve point positions (sorted by t)
            const xPoints = [...xEditor.points].sort((a, b) => a.t - b.t).map(p => p.t.toFixed(2)).join(',');
            
            // Get Y curve point positions (sorted by t)
            const yPoints = [...yEditor.points].sort((a, b) => a.t - b.t).map(p => p.t.toFixed(2)).join(',');
            
            // Build filename: prism_size_noise_feather_colors_dither_xCurve_yCurve.png
            const filename = `prism_${width}x${height}_noise-${noiseVal}_feather-${featherVal}_colors-${colors}${ditherInfo}_x-${xPoints}_y-${yPoints}.png`;

            // Export the image - use highest quality PNG with full RGB color mode
            // For dithered images, we want to preserve full color depth
            let dataUrl;
            try {
              // Use toDataURL with explicit quality (though PNG doesn't use quality, this ensures RGB mode)
              // The browser will save as RGB PNG (not indexed/palette) when colors are not quantized
              dataUrl = exportCanvas.toDataURL('image/png');
            } catch (toDataUrlError) {
              console.error('toDataURL error:', toDataUrlError);
              throw new Error('Failed to convert canvas to data URL: ' + toDataUrlError.message);
            }
            
            if (!dataUrl || dataUrl === 'data:,') {
              throw new Error('toDataURL returned invalid data');
            }

      const link = document.createElement('a');
            link.download = filename;
            link.href = dataUrl;
            document.body.appendChild(link);
      link.click();
            document.body.removeChild(link);
            
            // Remove loading state
            exportBtn.classList.remove('loading');
            exportBtn.disabled = false;
            exportBtnIcon.textContent = originalIcon;
            if (exportBtnText) {
              exportBtnText.textContent = originalText;
            }
          } catch (error) {
            console.error('Export error:', error);
            console.error('Error stack:', error.stack);
            alert('Export failed: ' + (error.message || 'Unknown error') + '. Please check the console for details.');
            // Remove loading state on error
            exportBtn.classList.remove('loading');
            exportBtn.disabled = false;
            exportBtnIcon.textContent = originalIcon;
            if (exportBtnText) {
              exportBtnText.textContent = originalText;
            }
          }
        }, 50);
      });
    });

    // Global scroll handler - scroll sidebar from anywhere on page
    const sidebarElement = document.querySelector('.sidebar');
    document.addEventListener('wheel', (e) => {
      // Skip if over input/textarea/select or modal
      const target = e.target;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT' || target.closest('.help-modal')) {
        return;
      }
      
      // Skip if over floating UI elements (curves, export, help button)
      if (target.closest('.floating-curves') || target.closest('.floating-export') || target.closest('.help-button')) {
        return;
      }
      
      // Check if sidebar is scrollable
      if (sidebarElement && sidebarElement.scrollHeight > sidebarElement.clientHeight) {
        e.preventDefault();
        sidebarElement.scrollTop += e.deltaY;
      }
    }, { passive: false });

    // Help modal
    const helpButton = document.getElementById('helpButton');
    const helpModal = document.getElementById('helpModal');
    const closeHelpModal = document.getElementById('closeHelpModal');

    // Show/hide help modal
    if (helpButton) {
      helpButton.addEventListener('click', () => {
        helpModal.classList.add('visible');
      });
    }

    if (closeHelpModal) {
      closeHelpModal.addEventListener('click', () => {
        helpModal.classList.remove('visible');
      });
    }

    // Close modal when clicking outside
    if (helpModal) {
      helpModal.addEventListener('click', (e) => {
        if (e.target === helpModal) {
          helpModal.classList.remove('visible');
        }
      });
    }

    // Randomize
    // Randomize
    // Randomize
    const randomBtn = document.getElementById('randomBtn');
    randomBtn.addEventListener('click', () => {
      saveHistory(); // Save state before global randomize
      // Remove animating class if present to reset
      randomBtn.classList.remove('animating');
      // Force immediate reflow to restart animation
      void randomBtn.offsetWidth;
      // Start animation immediately
      randomBtn.classList.add('animating');
      // Remove class after animation completes
      setTimeout(() => {
        randomBtn.classList.remove('animating');
      }, 600);
      
      // STEP 1: Set amount of colors FIRST (3-11)
      const colorCount = Math.floor(Math.random() * 9) + 3; // 3 to 11
      multiColorCount.value = colorCount;
      multiColorCountSlider.value = colorCount;
      
      // Adjust stop count to match the new count
      const currentCount = gradientStopsArray.length;
      if (colorCount !== currentCount) {
        // Sort by position first to ensure we keep the right stops
        gradientStopsArray.sort((a, b) => a.position - b.position);
        
        if (colorCount < currentCount) {
          // Keep first 'colorCount' stops, remove the rest
          gradientStopsArray.splice(colorCount);
        } else if (colorCount > currentCount) {
          // Add stops evenly distributed with interpolated colors
          while (gradientStopsArray.length < colorCount) {
            const newIndex = gradientStopsArray.length;
            const position = newIndex / (colorCount - 1);
            const col = getColorFromGradient(position);
            gradientStopsArray.push({ id: stopIdCounter++, position, color: col });
          }
        }
        
        // Update selected stop index if needed
        if (selectedStopIndex >= gradientStopsArray.length) {
          selectedStopIndex = Math.max(0, gradientStopsArray.length - 1);
        }
        
        // Redistribute positions evenly
        const finalCount = gradientStopsArray.length;
        if (finalCount > 1) {
          gradientStopsArray.forEach((stop, i) => {
            stop.position = i / (finalCount - 1);
          });
        } else if (finalCount === 1) {
          gradientStopsArray[0].position = 0;
        }
      }

      // STEP 2: Randomize curves
      const curveSeed = Math.floor(Math.random() * 1000000);
      seededRNG.setSeed(curveSeed);
      const xComplexity = Math.floor(Math.random() * 3) + 3; // 3, 4, or 5
      const yComplexity = Math.floor(Math.random() * 3) + 3; // 3, 4, or 5
      xEditor.randomize(seededRNG, xComplexity);
      yEditor.randomize(seededRNG, yComplexity);
      xEditor.setMaxPoints(xComplexity);
      yEditor.setMaxPoints(yComplexity);

      // STEP 3: Randomize colors (now that count is set)
      const colorSeed = Math.floor(Math.random() * 1000000);
      seededRNG.setSeed(colorSeed);
      randomizeGradientStops();

      // STEP 4: Randomize global blend mode (skip noise randomization)
      const blendModes = ['avg', 'mul', 'screen', 'overlay', 'softlight', 'hardlight', 'difference', 'exclusion', 'darken', 'lighten', 'colorburn', 'colordodge'];
      const randomBlendMode = blendModes[Math.floor(Math.random() * blendModes.length)];
      blendMode.value = randomBlendMode;
      blendModeButtons.querySelectorAll('.blend-btn').forEach(b => {
        b.classList.remove('active');
        if (b.dataset.mode === randomBlendMode) {
          b.classList.add('active');
        }
      });
      
      // STEP 6: Final update of the gradient
      renderGradientBar();
      renderGradient();
    });



    function hexToRgb(hex) {
      const clean = hex.replace('#', '');
      const num = parseInt(clean, 16);
      return {
        r: (num >> 16) & 255,
        g: (num >> 8) & 255,
        b: num & 255
      };
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }

    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
          case g: h = ((b - r) / d + 2) / 6; break;
          case b: h = ((r - g) / d + 4) / 6; break;
        }
      }
      return { h: h * 360, s: s * 100, l: l * 100 };
    }

    function hslToRgb(h, s, l) {
      h /= 360; s /= 100; l /= 100;
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
      };
    }

    // Gradient stop management
    function renderGradientBar() {
      // Sort stops by position (create new array to avoid mutating original)
      const stops = [...gradientStopsArray].sort((a, b) => a.position - b.position);
      const gradientStr = stops.map(s => {
        const hex = rgbToHex(s.color.r, s.color.g, s.color.b);
        return `${hex} ${s.position * 100}%`;
      }).join(', ');
      gradientBar.style.background = `linear-gradient(to right, ${gradientStr})`;
      
      // Update stop elements efficiently
      const stopElements = gradientStops.querySelectorAll('.gradient-stop');
      stops.forEach((stop, sortedIndex) => {
        // Find original index in unsorted array using unique ID
        let index = gradientStopsArray.findIndex(s => s.id === stop.id);
        
        // Fallback: if ID matching fails, try to match by position and color
        if (index === -1) {
          index = gradientStopsArray.findIndex(s => 
            s.position === stop.position && 
            s.color.r === stop.color.r && 
            s.color.g === stop.color.g && 
            s.color.b === stop.color.b
          );
        }
        
        // If still not found, use sortedIndex as fallback (shouldn't happen)
        if (index === -1) {
          index = sortedIndex;
        }
        
        // Calculate transform to prevent overflow at edges
        // Stop is 24px wide, so 12px on each side
        // At position 0, we want left edge at 0%, so translateX should be 0 instead of -50%
        // At position 1, we want right edge at 100%, so translateX should be -100% instead of -50%
        const isLeftmost = sortedIndex === 0;
        const isRightmost = sortedIndex === stops.length - 1;
        let transformX = '-50%';
        if (isLeftmost && stop.position <= 0.01) {
          transformX = '0%'; // Leftmost stop - align left edge
        } else if (isRightmost && stop.position >= 0.99) {
          transformX = '-100%'; // Rightmost stop - align right edge
        }
        
        if (stopElements[sortedIndex]) {
          // Update existing element
          stopElements[sortedIndex].style.left = (stop.position * 100) + '%';
          stopElements[sortedIndex].style.transform = `translate(${transformX}, -50%)`;
          stopElements[sortedIndex].style.setProperty('--stop-transform-x', transformX);
          stopElements[sortedIndex].className = 'gradient-stop' + (index === selectedStopIndex ? ' selected' : '');
          stopElements[sortedIndex].dataset.index = index;
          stopElements[sortedIndex].style.backgroundColor = rgbToHex(stop.color.r, stop.color.g, stop.color.b);
        } else {
          // Create new element if needed
          const stopEl = document.createElement('div');
          stopEl.className = 'gradient-stop' + (index === selectedStopIndex ? ' selected' : '');
          stopEl.style.left = (stop.position * 100) + '%';
          stopEl.style.transform = `translate(${transformX}, -50%)`;
          stopEl.style.setProperty('--stop-transform-x', transformX);
          stopEl.style.backgroundColor = rgbToHex(stop.color.r, stop.color.g, stop.color.b);
          stopEl.dataset.index = index;
          gradientStops.appendChild(stopEl);
        }
      });
      
      // Remove excess elements if stops were removed
      // Convert NodeList to array to avoid stale references
      const currentStopElements = Array.from(gradientStops.querySelectorAll('.gradient-stop'));
      while (currentStopElements.length > stops.length) {
        const elementToRemove = currentStopElements.pop();
        if (elementToRemove && elementToRemove.parentNode) {
          elementToRemove.parentNode.removeChild(elementToRemove);
        }
      }
    }

    function selectStop(index) {
      // Ensure index is valid
      if (index < 0 || index >= gradientStopsArray.length) {
        console.warn('Invalid stop index:', index);
        return;
      }
      selectedStopIndex = index;
      const stop = gradientStopsArray[index];
      if (!stop) {
        console.warn('Stop not found at index:', index);
        return;
      }
      const rgb = stop.color;
      const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
      currentHue = hsl.h;
      currentSaturation = hsl.s;
      currentLightness = hsl.l;
      // Update color picker display
      const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
      colorHexInput.value = hex;
      colorPreview.style.background = hex;
      // Update spectrum and hue sliders to show the selected color
      drawSpectrum();
      drawHueSlider();
      updateMarkers();
      stopColorPicker.style.display = 'flex';
      renderGradientBar();
    }

    let colorUpdateTimeout = null;
    function updateSelectedStopColor(r, g, b) {
      if (selectedStopIndex >= 0 && selectedStopIndex < gradientStopsArray.length) {
        gradientStopsArray[selectedStopIndex].color = { r, g, b };
        renderGradientBar();
        
        // Throttle gradient rendering during color updates for smooth interaction
        if (colorUpdateTimeout) {
          clearTimeout(colorUpdateTimeout);
        }
        colorUpdateTimeout = setTimeout(() => {
          saveHistory(); // Save history when color change is complete
          renderGradient();
        }, 16); // ~60fps throttling
      }
    }

    function addStop(position) {
      // Sort stops to find adjacent stops
      const stops = [...gradientStopsArray].sort((a, b) => a.position - b.position);
      
      // Find the two stops that the new position falls between
      let col;
      if (stops.length === 0) {
        // Default color if no stops exist
        col = { r: 128, g: 128, b: 128 };
      } else if (position <= stops[0].position) {
        // Before first stop - use first stop's color
        col = { ...stops[0].color };
      } else if (position >= stops[stops.length - 1].position) {
        // After last stop - use last stop's color
        col = { ...stops[stops.length - 1].color };
      } else {
        // Between two stops - interpolate
        for (let i = 0; i < stops.length - 1; i++) {
          const s1 = stops[i];
          const s2 = stops[i + 1];
          if (position >= s1.position && position <= s2.position) {
            const localT = (position - s1.position) / (s2.position - s1.position);
            col = {
              r: Math.round(lerp(s1.color.r, s2.color.r, localT)),
              g: Math.round(lerp(s1.color.g, s2.color.g, localT)),
              b: Math.round(lerp(s1.color.b, s2.color.b, localT))
            };
            break;
          }
        }
      }
      
      gradientStopsArray.push({ id: stopIdCounter++, position, color: col });
      selectedStopIndex = gradientStopsArray.length - 1;
      selectStop(selectedStopIndex);
      renderGradientBar();
      // Immediately render gradient (no throttling for addition)
      renderGradient();
    }

    function removeStop(index) {
      if (gradientStopsArray.length > 2) {
        saveHistory(); // Save state before removing stop
        // Clear any pending color update timeouts
        if (colorUpdateTimeout) {
          clearTimeout(colorUpdateTimeout);
          colorUpdateTimeout = null;
        }
        
        gradientStopsArray.splice(index, 1);
        if (selectedStopIndex >= gradientStopsArray.length) {
          selectedStopIndex = gradientStopsArray.length - 1;
        }
        
        // Update the colors input field and slider to match the new number of stops
        const newCount = gradientStopsArray.length;
        multiColorCount.value = newCount;
        if (newCount >= 2 && newCount <= 20) {
          multiColorCountSlider.value = newCount;
        }
        
        renderGradientBar();
        // Immediately render gradient (no throttling for removal)
        renderGradient();
      }
    }

    function randomizeGradientStops() {
      const count = parseInt(multiColorCount.value) || 3;
      
      // Sort by position first
      gradientStopsArray.sort((a, b) => a.position - b.position);
      
      // Adjust stop count to match requested count
      if (gradientStopsArray.length < count) {
        // Add stops evenly distributed
        while (gradientStopsArray.length < count) {
          const newIndex = gradientStopsArray.length;
          const position = newIndex / (count - 1);
          const col = getColorFromGradient(position);
          gradientStopsArray.push({ id: stopIdCounter++, position, color: col });
        }
      } else if (gradientStopsArray.length > count) {
        // Remove last stops until we reach the desired count
        while (gradientStopsArray.length > count) {
          // Remove the last stop (keep first stop at position 0)
          if (gradientStopsArray.length > 1) {
            gradientStopsArray.pop();
          } else {
            break; // Safety break
          }
        }
      }
      
      // Redistribute positions evenly and randomize colors
      gradientStopsArray.forEach((stop, i) => {
        stop.position = i / (count - 1);
        stop.color = {
          r: seededRNG.randomInt(0, 255),
          g: seededRNG.randomInt(0, 255),
          b: seededRNG.randomInt(0, 255)
        };
      });
      
      // Clear activePalette since we're using gradient stops
      activePalette = null;
      
      // Update selected stop if needed
      if (selectedStopIndex >= gradientStopsArray.length) {
        selectedStopIndex = gradientStopsArray.length - 1;
      }
      
      // Always update both the bar and the gradient
      renderGradientBar();
      renderGradient();
    }

    function updateColorFromHsl() {
      const rgb = hslToRgb(currentHue, currentSaturation, currentLightness);
      const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
      colorHexInput.value = hex;
      colorPreview.style.background = hex;
      updateSelectedStopColor(rgb.r, rgb.g, rgb.b);
    }

    function updateColorFromHex(hex) {
      const rgb = hexToRgb(hex);
      const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
      currentHue = hsl.h;
      currentSaturation = hsl.s;
      currentLightness = hsl.l;
      colorPreview.style.background = hex;
      updateSelectedStopColor(rgb.r, rgb.g, rgb.b);
      drawSpectrum();
      drawHueSlider();
      updateMarkers();
    }

    function drawHueSlider() {
      const rect = hueCanvas.getBoundingClientRect();
      hueCanvas.width = rect.width;
      hueCanvas.height = rect.height;
      const width = hueCanvas.width;
      const height = hueCanvas.height;
      const gradient = hueCtx.createLinearGradient(0, 0, width, 0);
      for (let i = 0; i <= 360; i += 30) {
        const rgb = hslToRgb(i, 100, 50);
        gradient.addColorStop(i / 360, `rgb(${rgb.r},${rgb.g},${rgb.b})`);
      }
      hueCtx.fillStyle = gradient;
      hueCtx.fillRect(0, 0, width, height);
    }

    function drawSpectrum() {
      const rect = spectrumCanvas.getBoundingClientRect();
      spectrumCanvas.width = rect.width;
      spectrumCanvas.height = rect.height;
      const width = spectrumCanvas.width;
      const height = spectrumCanvas.height;
      // Draw saturation gradient (left to right)
      for (let x = 0; x < width; x++) {
        const s = (x / width) * 100;
        // Draw lightness gradient (top to bottom)
        const grad = spectrumCtx.createLinearGradient(0, 0, 0, height);
        // Start from White (100%) at top to Black (0%) at bottom
        for (let l = 100; l >= 0; l -= 10) {
          const rgb = hslToRgb(currentHue, s, l);
          grad.addColorStop((100 - l) / 100, `rgb(${rgb.r},${rgb.g},${rgb.b})`);
        }
        spectrumCtx.fillStyle = grad;
        spectrumCtx.fillRect(x, 0, 1, height);
      }
    }

    function updateMarkers() {
      const spectrumRect = spectrumCanvas.getBoundingClientRect();
      const hueRect = hueCanvas.getBoundingClientRect();
      const sx = (currentSaturation / 100) * spectrumRect.width;
      const sy = (1 - currentLightness / 100) * spectrumRect.height;
      const hx = (currentHue / 360) * hueRect.width;
      spectrumMarker.style.left = sx + 'px';
      spectrumMarker.style.top = sy + 'px';
      hueMarker.style.left = hx + 'px';
    }


    // Gradient stop interactions
    let wasDragging = false; // Track if we just finished dragging
    const gradientBarContainer = document.querySelector('.gradient-bar-container');
    
    // Prevent pointerdown on container from interfering with stop dragging
    gradientBarContainer.addEventListener('pointerdown', (e) => {
      // If clicking on a stop, let the stop handle it - don't interfere
      if (e.target.classList.contains('gradient-stop') || e.target.closest('.gradient-stop')) {
        // Don't prevent default or stop propagation - let the stop's handler take over
        return;
      }
    });
    
    gradientBarContainer.addEventListener('click', (e) => {
      // Don't add stop if we just finished dragging a stop
      if (wasDragging) {
        wasDragging = false;
        return;
      }
      // Only add stop if clicking on the gradient bar itself, not on a stop
      if (!e.target.classList.contains('gradient-stop') && !e.target.closest('.gradient-stop')) {
        const rect = gradientBar.getBoundingClientRect();
        const position = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        addStop(position);
      }
    });

    gradientStops.addEventListener('click', (e) => {
      if (e.target.classList.contains('gradient-stop')) {
        const index = parseInt(e.target.dataset.index);
        selectStop(index);
      }
    });

    // Drag stops
    let draggingStop = null;
    let renderGradientTimeout = null;
    let originalStopPositions = null; // Store original positions when drag starts
    
    gradientStops.addEventListener('pointerdown', (e) => {
      // Check if clicking on a stop or any child element
      const stopElement = e.target.classList.contains('gradient-stop') 
        ? e.target 
        : e.target.closest('.gradient-stop');
      
      if (stopElement) {
        // Try to get index from dataset, fallback to finding by stopId
        let index = parseInt(stopElement.dataset.index);
        if (isNaN(index) && stopElement.dataset.stopId) {
          const stopId = parseInt(stopElement.dataset.stopId);
          index = gradientStopsArray.findIndex(s => s.id === stopId);
        }
        if (isNaN(index) || index < 0) return;
        
        isPointerDown = true;
        hasMoved = false;
        pointerDownX = e.clientX;
        
        // Select the stop and update color picker
        selectStop(index);
        
        draggingStop = {
          index: index,
          element: stopElement,
          stopId: gradientStopsArray[index].id
        };
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation(); // Prevent any other handlers from running
        
        // Store original positions of all stops to prevent them from moving
        originalStopPositions = gradientStopsArray.map((stop, idx) => ({
          index: idx,
          position: stop.position
        }));
        
        // Disable pointer events on all other stops while dragging
        // This allows the dragged stop to pass over other stops
        const allStops = gradientStops.querySelectorAll('.gradient-stop');
        allStops.forEach((stop) => {
          const stopIndex = parseInt(stop.dataset.index);
          if (stopIndex !== index) {
            stop.style.pointerEvents = 'none';
          } else {
            // Bring dragged stop to front with higher z-index
            stop.style.zIndex = '1000';
          }
        });
      }
    });

    window.addEventListener('pointermove', (e) => {
      if (isPointerDown && draggingStop && originalStopPositions) {
        // Check if mouse actually moved (more than 3px)
        if (!hasMoved && pointerDownX !== null) {
          if (Math.abs(e.clientX - pointerDownX) > 3) {
            hasMoved = true;
          }
        }
        
        if (hasMoved && draggingStop.stopId) {
          // Find the dragged stop by ID (not index, to ensure we get the right one)
          const draggedStop = gradientStopsArray.find(s => s.id === draggingStop.stopId);
          if (!draggedStop) return;
          
          const rect = gradientBar.getBoundingClientRect();
          let position = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
          
          // Constrain position to avoid overlapping with other stops (minimum distance)
          const minDistance = 0.01; // 1% minimum distance
          
          // Check against original positions of other stops (by ID)
          originalStopPositions.forEach(original => {
            if (original.id === draggingStop.stopId) return; // Skip the dragged stop
            
            const otherPosition = original.position;
            
            // If we're too close to another stop, push away
            if (Math.abs(position - otherPosition) < minDistance) {
              if (position > otherPosition) {
                position = otherPosition + minDistance;
              } else {
                position = otherPosition - minDistance;
              }
              // Clamp to valid range
              position = Math.max(0, Math.min(1, position));
            }
          });
          
          // Restore all other stops to their original positions (by ID, not index)
          originalStopPositions.forEach(original => {
            if (original.id !== draggingStop.stopId) {
              const stop = gradientStopsArray.find(s => s.id === original.id);
              if (stop) {
                // Only update position, never touch color
                stop.position = original.position;
              }
            }
          });
          
          // Update ONLY the dragged stop's position (never touch color)
          draggedStop.position = position;
          
          // Update gradient bar immediately for smooth visual feedback
          renderGradientBar();
          
          // Throttle gradient rendering during drag for performance
          if (renderGradientTimeout) {
            clearTimeout(renderGradientTimeout);
          }
          renderGradientTimeout = setTimeout(() => {
            renderGradient();
          }, 16); // ~60fps throttling
        }
      }
    });

    window.addEventListener('pointerup', (e) => {
      if (draggingStop) {
        // Save history when gradient stop drag ends
        saveHistory();
        // Clear any pending render
        if (renderGradientTimeout) {
          clearTimeout(renderGradientTimeout);
          renderGradientTimeout = null;
        }
        // Final render on release
        renderGradient();
        
        // Re-enable pointer events on all stops
        const allStops = gradientStops.querySelectorAll('.gradient-stop');
        allStops.forEach((stop) => {
          stop.style.pointerEvents = 'all';
          stop.style.zIndex = '';
        });
        
        // Mark that we were dragging to prevent click handler from adding stops
        wasDragging = true;
        // Clear the flag after a short delay to allow click events to be processed first
        setTimeout(() => {
          wasDragging = false;
        }, 100);
        
        // Clear original positions
        originalStopPositions = null;
        draggingStop = null;
      }
    });

    removeStopBtn.addEventListener('click', () => {
      if (selectedStopIndex >= 0 && gradientStopsArray.length > 2) {
        removeStop(selectedStopIndex);
      }
    });

    // Invert gradient function
    function invertGradient() {
      saveHistory(); // Save state before inverting
      gradientStopsArray.forEach(stop => {
        stop.position = 1 - stop.position;
      });
      renderGradientBar();
      renderGradient();
    }

    const invertGradientBtn = document.getElementById('invertGradientBtn');
    invertGradientBtn.addEventListener('click', () => {
      invertGradient();
    });

    const redistributeStopsBtn = document.getElementById('redistributeStopsBtn');
    redistributeStopsBtn.addEventListener('click', () => {
      saveHistory(); // Save state before redistributing
      // Sort stops by position first
      gradientStopsArray.sort((a, b) => a.position - b.position);
      // Redistribute positions evenly
      const count = gradientStopsArray.length;
      if (count > 1) {
        gradientStopsArray.forEach((stop, i) => {
          stop.position = i / (count - 1);
        });
        renderGradientBar();
        renderGradient();
      }
    });

    // Shuffle colors between stops
    function shuffleColors() {
      saveHistory(); // Save state before shuffling
      // Create an array of all colors
      const colors = gradientStopsArray.map(stop => ({ ...stop.color }));
      
      // Shuffle the colors array using Fisher-Yates algorithm
      for (let i = colors.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [colors[i], colors[j]] = [colors[j], colors[i]];
      }
      
      // Assign shuffled colors back to stops (keeping positions the same)
      gradientStopsArray.forEach((stop, i) => {
        stop.color = colors[i];
      });
      
      renderGradientBar();
      renderGradient();
    }

    const shuffleColorsBtn = document.getElementById('shuffleColorsBtn');
    shuffleColorsBtn.addEventListener('click', () => {
      shuffleColors();
    });

    // Randomize colors button handler
    randomizeColorsBtn.addEventListener('click', () => {
      saveHistory(); // Save state before randomizing colors
      const seed = Math.floor(Math.random() * 1000000);
      seededRNG.setSeed(seed);
      randomizeGradientStops();
    });

    // Sync slider and number input for color count
    multiColorCountSlider.addEventListener('input', () => {
      multiColorCount.value = multiColorCountSlider.value;
      const count = parseInt(multiColorCountSlider.value) || 8;
      
      // Adjust stop count without randomizing colors
      const currentCount = gradientStopsArray.length;
      if (count !== currentCount) {
        saveHistory(); // Save state before changing color count
        // Sort by position first to ensure we keep the right stops
        gradientStopsArray.sort((a, b) => a.position - b.position);
        
        if (count < currentCount) {
          // Keep first 'count' stops, remove the rest
          gradientStopsArray.splice(count);
        } else if (count > currentCount) {
          // Add stops evenly distributed with interpolated colors
          while (gradientStopsArray.length < count) {
            const newIndex = gradientStopsArray.length;
            const position = newIndex / (count - 1);
            const col = getColorFromGradient(position);
            gradientStopsArray.push({ id: stopIdCounter++, position, color: col });
          }
        }
        
        // Update selected stop index if needed
        if (selectedStopIndex >= gradientStopsArray.length) {
          selectedStopIndex = Math.max(0, gradientStopsArray.length - 1);
        }
        
        // Redistribute positions evenly
        const finalCount = gradientStopsArray.length;
        if (finalCount > 1) {
          gradientStopsArray.forEach((stop, i) => {
            stop.position = i / (finalCount - 1);
          });
        } else if (finalCount === 1) {
          gradientStopsArray[0].position = 0;
        }
        
        // Force complete re-render
        renderGradientBar();
        renderGradient();
      }
    });

    multiColorCount.addEventListener('input', () => {
      const val = Math.min(20, Math.max(2, parseInt(multiColorCount.value) || 8));
      multiColorCount.value = val;
      // Update slider only if value is within slider range (2-20)
      if (val >= 2 && val <= 20) {
        multiColorCountSlider.value = val;
      }
      
      const count = val;
      // Adjust stop count without randomizing colors
      const currentCount = gradientStopsArray.length;
      if (count !== currentCount) {
        saveHistory(); // Save state before changing color count
        // Sort by position first to ensure we keep the right stops
        gradientStopsArray.sort((a, b) => a.position - b.position);
        
        if (count < currentCount) {
          // Keep first 'count' stops, remove the rest
          gradientStopsArray.splice(count);
        } else if (count > currentCount) {
          // Add stops evenly distributed with interpolated colors
          while (gradientStopsArray.length < count) {
            const newIndex = gradientStopsArray.length;
            const position = newIndex / (count - 1);
            const col = getColorFromGradient(position);
            gradientStopsArray.push({ id: stopIdCounter++, position, color: col });
          }
        }
        
        // Update selected stop index if needed
        if (selectedStopIndex >= gradientStopsArray.length) {
          selectedStopIndex = Math.max(0, gradientStopsArray.length - 1);
        }
        
        // Redistribute positions evenly
        const finalCount = gradientStopsArray.length;
        if (finalCount > 1) {
          gradientStopsArray.forEach((stop, i) => {
            stop.position = i / (finalCount - 1);
          });
        } else if (finalCount === 1) {
          gradientStopsArray[0].position = 0;
        }
        
        // Force complete re-render
        renderGradientBar();
        renderGradient();
      }
    });

    // Color picker interactions (for editing selected stop)
    spectrumCanvas.addEventListener('pointerdown', (e) => {
      e.stopPropagation(); // Prevent event from reaching other handlers
      const rect = spectrumCanvas.getBoundingClientRect();
      const update = (ev) => {
        const x = Math.max(0, Math.min(ev.clientX - rect.left, rect.width));
        const y = Math.max(0, Math.min(ev.clientY - rect.top, rect.height));
        currentSaturation = (x / rect.width) * 100;
        currentLightness = 100 - (y / rect.height) * 100;
        updateColorFromHsl();
        updateMarkers();
      };
      update(e);
      const onMove = (ev) => {
        update(ev);
        ev.stopPropagation(); // Prevent interference with curve editor
      };
      const onUp = () => {
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
      };
      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', onUp);
    });

    hueCanvas.addEventListener('pointerdown', (e) => {
      e.stopPropagation(); // Prevent event from reaching other handlers
      const rect = hueCanvas.getBoundingClientRect();
      const update = (ev) => {
        const x = Math.max(0, Math.min(ev.clientX - rect.left, rect.width));
        currentHue = (x / rect.width) * 360;
        drawSpectrum();
        updateColorFromHsl();
        updateMarkers();
      };
      update(e);
      const onMove = (ev) => {
        update(ev);
        ev.stopPropagation(); // Prevent interference with curve editor
      };
      const onUp = () => {
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
      };
      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', onUp);
    });

    colorHexInput.addEventListener('change', () => {
      let val = colorHexInput.value;
      if (!val.startsWith('#')) val = '#' + val;
      if (/^#[0-9A-Fa-f]{6}$/.test(val)) {
        updateColorFromHex(val);
      }
    });

    // Initial setup
    // Ensure curves are enabled by default
    if (curvesVisible) {
      document.getElementById('xCurveCanvas').classList.add('curves-enabled');
      document.getElementById('yCurveCanvas').classList.add('curves-enabled');
    }
    
    // Initialize curves with random values (3-5 points each)
    const randomSeed = Math.floor(Math.random() * 1000000);
    const tempRNG = new SeededRNG(randomSeed);
    const xComplexity = Math.floor(Math.random() * 3) + 3; // 3, 4, or 5
    const yComplexity = Math.floor(Math.random() * 3) + 3; // 3, 4, or 5
    xEditor.randomize(tempRNG, xComplexity);
    yEditor.randomize(tempRNG, yComplexity);
    xEditor.setMaxPoints(xComplexity);
    yEditor.setMaxPoints(yComplexity);
    renderGradientBar();
    selectStop(0);
    drawHueSlider();
    drawSpectrum();
    updateMarkers();
        renderGradient();
    setCanvasSize();
    window.addEventListener('resize', setCanvasSize);
    
    // Initialize button states (both disabled until first user action)
    updateHistoryButtons();
  </script>
</body>

</html>